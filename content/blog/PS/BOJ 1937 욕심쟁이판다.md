---
title: '[백준 1937] 욕심쟁이 판다 (Node.js)'
date: 2022-04-07 15:36:13
category: 'PS'
draft: false
---

## 문제

[1937번: 욕심쟁이 판다](https://www.acmicpc.net/problem/1937)

### 문제 풀이

BFS로 풀었을 때는 시간초과로 통과를 받지 못한 문제이다. 이는 Dynamic Programming을 통해서 풀 수 있다.

`DP[a][b] = c` 의 의미는 판다가 (a, b)의 위치에 있을 때 최대로 방문할 수 있는 칸이 c임을 의미한다. 재귀호출을 통해서 문제를 해결할 수 있다. DFS를 통해서 상하좌우 중 탐색할 수 있는 좌표에 대해서 탐색을 수행한다.

이 때 이미 방문한 좌표에 대해서는 더 이상 방문하지 않는다. 왜냐하면 이미 방문한 좌표의 DP값은 이미 재귀 호출을 통한 탐색이 완료된 상태이기 때문에 재귀를 다시 수행해도 동일한 결과를 산출하기 때문이다.

move함수를 살펴보면 이미 방문한 적이 있는 좌표에 대해서는 해당 dp[x][y]를 반환하고, 그렇지 않다면 1이라는 값을 할당한다. 그리고 4방향에 대한 탐색을 수행한다. 이 때 해당 좌표가 방문이 가능한지, 새로운 좌표가 이전 좌표에 비해 더 많은 대나무의 양이라는 조건을 만족해야한다. 해당 좌표가 방문 가능하다면 dp[x][y]의 값은 현재의 본인 값 또는 해당 좌표로 탐색을 진행했을 때 산출되는 반환 값 + 1 이다.

### Code

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const N = +input[0]
  const board = input.slice(1).map(v => v.split(' ').map(Number))
  const dp = Array.from({ length: N }, () => new Array(N).fill(0))
  const dx = [0, 1, 0, -1]
  const dy = [1, 0, -1, 0]

  let answer = -Infinity
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      answer = Math.max(answer, move(i, j))
    }
  }

  log(answer)

  function move(x, y) {
    if (dp[x][y] !== 0) return dp[x][y]
    dp[x][y] = 1
    for (let dir = 0; dir < 4; dir++) {
      const [nx, ny] = [x + dx[dir], y + dy[dir]]
      if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue
      if (board[nx][ny] <= board[x][y]) continue
      dp[x][y] = Math.max(dp[x][y], move(nx, ny) + 1)
    }

    return dp[x][y]
  }
}

solution(input)
```

### Recap

재귀 문제는 아직도 푸는데 어려움이 있는 것 같다. 이전에 라인 코딩테스트 문제에서도 유사한 유형이 나왔던 기억이 있다. 그 때도 DFS로 풀려고 시도했었는데 사실 DP문제였었던것 같다. 재귀에 대한 연습을 더 꾸준하게 해야겠다.
