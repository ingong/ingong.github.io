---
title: '[BOJ 11055] 가장 큰 증가하는 부분수열 (Node.js)'
date: 2022-03-03 16:21:13
category: 'PS'
draft: false
---

## 문제

[11055번: 가장 큰 증가 부분 수열](https://www.acmicpc.net/problem/11055)

## 문제 접근

DP는 한 가지 문제에 대해서 단 한번만 풀도록 만들어주는 알고리즘이다. Optional Substructure 에서 효과를 발휘하는데 이는 답을 구하기 위한 계산을 반복하는 문제 구조이다.
DP는 작은 문제들 속에서 계속 반복되는 연산을 활용해 빠르게 해결할 수 있다. 분할 정복과 유사하지만 DP 는 부분 문제가 중복되지만 분할 정복은 중복되지 않는다.

## 풀이

처음 DP 의 값을 본인으로 초기화한다. 먼저 확인해야할 점은 증가하는 수열이기 때문에 이전에 선택할 수 있는 값은 본인의 값보다 작은 값이여야만한다.
또한 본인(i)에 저장된 DP `값인 DP[i]`과 해당 index 인 `DP[j]`값과 본인의 값인 `array[i]` 을 비교했을 때 더 크다면 이를 재할당한다.

즉, 앞에서부터 차례로 순회하면서

1. 본인보다 작은 값인지
2. 현재 `DP[i]` 의 값과 `DP[j] + array[i]` 를 비교하고, 후자가 더 큰 경우에는 이 값으로 초기화한다.

## 문제 회고

Edge Case 에 대한 고려가 필요하다. 문제의 조건에 양수라는 조건은 존재하지 않았다. 따라서 본인보다 작은 숫자를 만났더라도 그 숫자의 DP 값이 최대임을 보장할 수 없다.
또한 이러한 문제 유형은 숫자를 문자로 변경한다면 증가하는 문자열에도 적용할 수 있다. 처음에는 이러한 유형의 점화식을 생각하는게 어려웠던 것 같다.

## 소스 코드

```tsx
const fs = require('fs')
// BAEKJOON
// const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = fs
  .readFileSync('TEST_CASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const N = +input[0]
  const array = input[1].split(' ').map(Number)
  const dp = input[1].split(' ').map(Number)

  for (let i = 1; i < array.length; i++) {
    for (let j = 0; j < i; j++) {
      if (array[j] < array[i] && dp[j] + array[i] > dp[i]) {
        dp[i] = dp[j] + array[i]
      }
    }
  }
  log(Math.max(...dp))
}

solution(input)
```
