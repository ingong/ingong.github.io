---
title: '[백준 2193] 이친수 (Node.js)'
date: 2022-03-14 17:31:13
category: 'PS'
draft: false
---

## 문제

[2193번: 이친수](https://www.acmicpc.net/problem/2193)

## 문제 풀이

각 자리수가 가지는 이친수의 개수를 `DP` 배열의 index 로 저장 후 계산한다. 점화식은 크게 2가지로 세울 수 있다.

```jsx
1. DP[n] = DP[1] + ... + DP[n - 2] + 1;
2. DP[n] = DP[n - 1] + DP[n - 2]
```

### 풀이1

앞에 자리수를 기준으로 생각한다. 5자리를 생각해보자.

`10_ _ _` 의 꼴을 가질 것이다. 그렇다면 `_ _ _` 는 0 으로 시작해도되고 1 로 시작해도되는 이친수의 집합일 것이다. 따라서 `DP[3], DP[2], DP[1]` 의 값을 가진다. 마지막으로 모든 자리수가 0 인 경우도 존재한다. 따라서 식을 세워보면 다음과 같다.

```jsx
DP[5] = DP[3] + DP[2] + DP[1] + 1
```

### 풀이2

끝자리를 기준으로 생각한다. 끝자리에 오는 수가 0 인 경우와 1 인 경우를 나눠서 생각할 수 있다.

만약 끝자리가 0 이라면 그 전 자리수는 0 과 1 모두 올 수 있다. 따라서 이 개수는 `DP[n - 1]` 의 값과 동일하다. 끝자리가 1 이라면 그 전 자리수는 무조건 0 이여만 한다. 따라서 그 개수는 `DP[n - 2]` 의 값과 동일하다.

## 문제 회고

JS 의 숫자 범위는 `2^53 - 1 ~ -(2^53 - 1)` 이다. 따라서 BigInt 를 활용해 계산하고 마지막에 `toString()` 을 통해 결과를 반환해야한다. 스스로의 풀이에 의심을 가져서 BigInt 말고 다른 반례를 고민하면서 시간을 조금 더 썼는데 두 가지 점화식 모두 해결할 수 있는 풀이라는 사실에 조금 더 안도할 수 있었던 것 같다!

## 소스 코드

### 풀이1

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const N = +input[0]
  const MAX = 90
  const dp = new Array(MAX + 1).fill(BigInt(0))
  dp[1] = BigInt(1)
  dp[2] = BigInt(1)

  for (let i = 3; i <= MAX; i++) {
    for (let j = 1; j <= i - 2; j++) {
      dp[i] += BigInt(dp[j])
    }
    dp[i] += BigInt(1)
  }
  log(dp[N].toString())
}

solution(input)
```

### 풀이 2

```jsx
// BAEKJOON
const input = require('fs')
  .readFileSync('/dev/stdin')
  .toString()
  .trim()
  .split('\n')
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
// const input = require('fs').readFileSync('TESTCASE/index.txt').toString().trim().split('\n');
const log = console.log

const solution = input => {
  const N = +input[0]
  const MAX = 90
  const dp = new Array(MAX + 1).fill(BigInt(0))
  dp[1] = BigInt(1)
  dp[2] = BigInt(1)

  for (let i = 3; i <= MAX; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  log(dp[N].toString())
}

solution(input)
```
