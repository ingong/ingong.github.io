---
title: '[BOJ 1753] 최단경로 (Node.js)'
date: 2022-03-24 13:21:13
category: 'PS'
draft: false
---

## 문제

[1753번: 최단경로](https://www.acmicpc.net/problem/1753)

## 문제 풀이

한 정점에서 다른 모든 정점까지 가는데 걸리는 최단 경로의 값, 즉 최소 비용을 구하는 문제이다. 하나의 정점에서 다른 모든 정점까지 걸리는 최소비용을 구하는 알고리즘으로는 다익스트라와 벨만포드 알고리즘이 있는데, 이 문제에서는 음의 가중치가 없기 때문에 다익스트라로 해결할 수 있다.

먼저 Graph에 주어진 노드쌍과 Cost를 입력해준다. 방향성이 있는 그래프이기 때문에 시작 점을 row에 넣고 해당 row에 `[cost, to]` 를 넣어준다. 다음 다익스트라를 수행한다. 다익스트라는 현재 정점에 연결된 노드의 연결 비용 중 가장 적은 비용을 선택하는 방식이다. JS에서는 이를 최소힙과 우선순위큐를 활용해서 문제를 풀 수 있다.

현재 연결된 정점에 대한 결과값을 반환하고 이를 순회하면서 현재 dist에 저장된 값보다 작은 경우 이를 최신화해주고 우선순위 큐에 넣어준다. 우선순위큐가 빌 때까지 노드를 탐색하고 dist배열이 결국 시작 노드에서의 연결 비용을 의미한다.

## Recap

최소 비용 문제의 경우인데 방문 처리를 확인한다는 목적으로 dist를 -1로 초기화하는 실수를 했다. 다익스트라 알고리즘을 구현하는 방식을 살펴보면서 왜 음수일 때는 다익스트라 알고리즘을 사용하지 못하는지에 대해서 학습할 수 있어서 재밌었다. 뭔가 알고리즘을 하나씩 다시 공부하면서 지금까지는 원리를 모른채 활용하는 경우도 있었다는 느낌을 받았다. 좀 더 원리에 기반해 지식을 학습하고 이를 활용하는 능력을 기르기위해 노력해야겠다.

## Code

```jsx
class PriorityQueue extends Heap {
  constructor() {
    super()
  }

  enqueue = (priority, value) => this.insert(priority, value)
  dequeue = () => this.remove()
  isEmpty = () => this.heap.length <= 0
}
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const [V, E] = input[0].split(' ').map(Number)
  const start = +input[1]
  const connectList = input.slice(2).map(v => v.split(' ').map(Number))
  const dist = new Array(V + 1).fill(Infinity) // error
  dist[start] = 0
  const graph = Array.from({ length: V + 1 }, () => [])
  connectList.forEach(([from, to, cost]) => {
    graph[from].push([cost, to])
  })
  dijkstra(graph)

  function dijkstra(graph) {
    const priorityQueue = new PriorityQueue()
    priorityQueue.enqueue(0, start)
    dist[start] = 0

    while (!priorityQueue.isEmpty()) {
      const { cost, node } = priorityQueue.dequeue()
      for (const [nextCost, to] of graph[node]) {
        if (cost + nextCost < dist[to]) {
          dist[to] = cost + nextCost
          priorityQueue.enqueue(cost + nextCost, to)
        }
      }
    }

    const answer = dist
      .slice(1)
      .map(v => {
        if (v === Infinity) return 'INF'
        else return v
      })
      .join('\n')
    log(answer)
  }
}

solution(input)
```
