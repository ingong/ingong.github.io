---
title: '[BOJ 18870] 좌표 압축 (Node.js)'
date: 2022-03-31 14:40:13
category: 'PS'
draft: false
---

## 문제

[18870번: 좌표 압축](https://www.acmicpc.net/problem/18870)

## 문제 풀이

본인보다 작은 서로 다른 원소의 개수를 반환하는 문제이다. 문제의 제한 조건이 N이 1,000,000 이고 각각의 수에 대한 좌표 압축을 해야하기 때문에 선형 탐색의 방식으로는 문제를 풀 수 없다. 따라서 lowerBound를 활용해 해당 값이 나오는 최초 index를 반환하도록 문제를 풀었다. 문제에서는 무조건 target이 존재하기 때문에 target이 존재하지 않는 경우는 고려하지 않고 문제를 풀었다.

생각해볼만한 내용은 선형 탐색의 대상이 되는 배열을 set을 통해 중복을 제거해주는 것이였다. 원하는 target이 등장하는 최초 index를 원하기 때문에 정렬된 배열을 순회하고 set을 만드는 것보다는 set을 만든 배열을 순회하는 방식이 더 효율적이다.

## Recap

효율성을 생각하지 않고 그냥 문제를 푸는 나쁜 방식으로 문제에 접근했다. 처음에는 정렬된 배열에 대한 이분탐색을 수행하고 이를 set으로 만들어 size를 반환시키는 형태로 문제를 풀었다. 이는 백준에서 메모리 초과가 발생하게 했다. 따라서 이분 탐색의 대상 자체를 set으로 만든 후 탐색해 index를 반환하는 형태로 문제를 다시 풀었다.

## Code

```tsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const N = +input[0]
  const arr = input[1].split(' ').map(v => Number(v))
  const set = [...new Set(arr)].sort((a, b) => a - b)

  log(arr.map(v => lowerBound(v)).join(' '))

  function lowerBound(target) {
    let [start, end] = [0, N]
    while (start < end) {
      const mid = Math.floor((start + end) / 2)
      if (set[mid] < target) start = mid + 1
      else end = mid
    }
    return start
  }
}

solution(input)
```
