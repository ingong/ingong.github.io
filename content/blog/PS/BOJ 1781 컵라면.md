---
title: '[백준 1781] 컵라면 (Node.js)'
date: 2022-03-14 16:14:13
category: 'PS'
draft: false
---

## 문제 설명

[1781번: 컵라면](https://www.acmicpc.net/problem/1781)

## 문제 풀이

지금하는 선택이 최선의 선택이 아닐 수도 있다는 것을 염두에 두고 접근해야하는 문제이다. 데드라인을 기준으로 배열을 정렬한다. 처음에 문제를 풀 때는 stack 에 값을 넣고 stack 의 마지막 요소의 값과 새로 들어갈 요소를 비교해서 stack 에 있는 요소의 컵라면의 개수가 더 작다면 pop 해주는 방식으로 구현을 했다.

하지만 반례가 있었다. 다음과 같이 데드라인과 컵라면의 조합이 있고 N 은 2 라고 가정하자. 기존에 풀었던 풀이에 따르면 `(1, 2), (2, 10)` 의 조합을 얻게 된다. 하지만 데드라인이 1인 문제를 선택하지 않고 데드라인이 2인 두개의 문제를 푸는게 더 효율적인 선택이다.

```jsx
데드라인 | 컵라면
	1       2
  2      10
	2       3
```

따라서 우선순위 큐를 활용해 문제를 풀어야했다. 우선순위 큐는 최소 힙을 사용해 구현했으며 컵라면의 개수를 기준으로 정렬해 작은 컵라면이 제거되도록 문제를 풀었다. 우선순위 큐의 길이가 deadline 보다 크다면 제일 상위의 요소(컵라면의 개수가 가장 작은) 를 제거시켜주고, 우선순위 큐에 들어있는 컵라면의 요소의 합이 최대가 되도록 작성했다.

## 문제 회고

그리디 문제는 그 사고방식을 학습하는게 중요하고 문제를 풀면서 학습해야한다는 것을 알 수 있었다. 또한 평소 우선순위 큐 문제는 자주 사용되지 않는다는 핑계로 제대로 학습하지 않았었는데 이번 기회로 직접 구현도 해보고 정리도 할 수 있어서 좋았던 것 같다.

되돌이켜보면 개발을 시작하면서 항상 조급한 마음을 갖고 공부를 했고 효율을 생각하면서 공부했던 것 같다. 지식의 가치는 그 지식이 활용될 때 결정된다는 믿음을 다시 한 번 마음에 새기고 학습해야겠다.

## 소스 코드

```jsx
class Heap {
  constructor() {
    this.heap = []
  }

  getLeftChildIndex = parentIndex => parentIndex * 2 + 1
  getRightChildIndex = parentIndex => parentIndex * 2 + 2
  getParentIndex = childIndex => Math.floor((childIndex - 1) / 2)

  peek = () => this.heap[0]

  insert = (key, value) => {
    const node = { key, value }
    this.heap.push(node)
    this.heapifyUp()
  }

  heapifyUp = () => {
    let index = this.heap.length - 1
    const lastInsertedNode = this.heap[index]

    while (index > 0) {
      const parentIndex = this.getParentIndex(index)

      if (this.heap[parentIndex].key > lastInsertedNode.key) {
        this.heap[index] = this.heap[parentIndex]
        index = parentIndex
      } else break
    }

    this.heap[index] = lastInsertedNode
  }

  remove = () => {
    const count = this.heap.length
    const rootNode = this.heap[0]

    if (count <= 0) return undefined
    if (count === 1) this.heap = []
    else {
      this.heap[0] = this.heap.pop()
      this.heapifyDown()
    }
    return rootNode
  }

  heapifyDown = () => {
    let index = 0
    const count = this.heap.length
    const rootNode = this.heap[index]

    while (this.getLeftChildIndex(index) < count) {
      const leftChildIndex = this.getLeftChildIndex(index)
      const rightChildIndex = this.getRightChildIndex(index)

      const smallerChildIndex =
        rightChildIndex < count &&
        this.heap[rightChildIndex].key < this.heap[leftChildIndex].key
          ? rightChildIndex
          : leftChildIndex

      if (this.heap[smallerChildIndex].key <= rootNode.key) {
        this.heap[index] = this.heap[smallerChildIndex]
        index = smallerChildIndex
      } else break
    }

    this.heap[index] = rootNode
  }
}

class PriorityQueue extends Heap {
  constructor() {
    super()
  }

  enqueue = (priority, value) => this.insert(priority, value)
  dequeue = () => this.remove()
  isEmpty = () => this.heap.length <= 0
}

// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const N = +input[0]
  const array = input.slice(1).map(v => v.split(' ').map(Number))
  const priorityQueue = new PriorityQueue()

  array.sort((a, b) => {
    if (a[0] - b[0] > 0) return 1
    else if (a[0] - b[0] === 0) return b[1] - a[1]
    else if (a[0] - b[0] < 0) return -1
  })

  for (let i = 0; i < N; i++) {
    priorityQueue.enqueue(array[i][1], array[i][0])
    const deadline = array[i][0]
    if (priorityQueue.heap.length > deadline) {
      priorityQueue.dequeue()
    }
  }
  log(priorityQueue.heap.reduce((acc, cur) => acc + cur.key, 0))
}

solution(input)
```
