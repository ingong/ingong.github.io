---
title: 'BOJ 15685'
date: 2022-03-04 16:21:13
category: '백준 알고리즘'
draft: false
---

## 문제

[15685번: 드래곤 커브](https://www.acmicpc.net/problem/15685)

## 문제 접근

새로운 드래곤 커브를 만들 때 이전 단계에서의 방향을 토대로 만들어진다는 아이디어를 기반으로 접근하면 된다.

```tsx
// 오른쪽, 위, 왼쪽, 아래
const dx = [1, 0, -1, 0]
const dy = [0, -1, 0, 1]
```

다음과 같은 4방향이 존재할 때 0 단계 드래콘 커브가 ➡️ 라고 가정하자.

1단계 드래곤 커브는 ➡️ 를 끝점을 기준으로 시계방향으로 회전시킨다면 ⬆️ 이 된다. 1단계 드래곤 커브는 ➡️ ⬆️ 이다.

2단계 드래곤 커브는 ⬆️ 를 시계방향으로 회전시키는 것이고 이는 왼쪽으로 향하게 된다. 그 다음은 ➡️ 를 시계방향으로 회전시킨 ⬆️ 방향이 된다. 크게 상관은 없는 규칙이지만 드래곤 커브는 2^(단계) 의 개수를 갖는다.

따라서 이전 방향들을 변수에 담고 이를 역순으로 접근해 새로운 방향의 배열을 만들어내면 된다.

## 문제 회고

총 소요시간은 2시간40분이 소요되었다. 풀이에 1시간이 걸렸고, 마지막 박스의 총 크기를 세는 과정에서 마지막 조건 누락으로 인해 런타임 에러가 발생했고 이를 찾는데 1시간40분이 걸렸다. 101 이라는 길이를 갖기 때문에 index 는 0 부터 100 까지 존재하고, 99 까지만 탐색하면 되었다. 런타임 에러가 나타나는 순간 백준의 입출력 오류라고 생각했던 점이 잘못한 점이였던 것 같다.

이 문제의 키포인트는 이전 드래곤 커브까지의 방향을 기반으로 새로운 방향이 만들어낸다는 것이 포인트였다. 복잡한 문제를 단순화시켜서 풀 필요가 있어보인다. 그러한 방법을 깨닫는 것은 문제를 많이 풀어보고 AC 를 받은 코드를 많이 보면서 체득할 수 있는 것 같다.

## 소스 코드

```tsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TEST_CASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const N = +input[0]
  const array = input.slice(1, N + 1).map(v => v.split(' ').map(Number))
  const board = Array.from({ length: 101 }, () => new Array(101).fill(0))

  const dx = [1, 0, -1, 0]
  const dy = [0, -1, 0, 1]

  for (let i = 0; i < N; i++) {
    let [x, y, d, g] = array[i]
    board[y][x] = true

    const dirList = getDirList(d, g)
    log(dirList)
    for (const dir of dirList) {
      ;[x, y] = [x + dx[dir], y + dy[dir]]
      board[y][x] = true
    }
  }

  function getDirList(d, g) {
    let answer = [d]
    for (let i = 1; i <= g; i++) {
      let temp = []
      for (let i = answer.length - 1; i > -1; i--) {
        const previous = answer[i]
        const after = (previous + 1) % 4
        temp.push(after)
      }
      answer.push(...temp)
    }
    return answer
  }

  let answer = 0
  for (let i = 0; i < 100; i++) {
    for (let j = 0; j < 100; j++) {
      if (
        board[i][j] &&
        board[i + 1][j] &&
        board[i][j + 1] &&
        board[i + 1][j + 1]
      )
        answer++
    }
  }
  log(answer)
}

solution(input)
```
