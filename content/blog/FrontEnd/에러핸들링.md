---
title: '에러 핸들링'
date: 2022-3-06 16:21:13
category: 'FrontEnd'
draft: false
---

## 오류란 무엇인가?

실패 실수 또는 오차, 컴퓨터 분야에서는 하드웨어의 고장 또는 **소프트웨어가 본래의 동작을 할 수 없는** 상태입니다.

### 발생 시점에 따라 분류되는 오류

**컴파일 오류**는 코드가 컴파일 될 때 컴파일러가 해석하지 못해서 발생합니다. 예를 들면 문법을 잘못 작성하는 경우가 있을 수 있습니다.

**런타임 오류**는 프로그램이 동작할 때 발견할 수 있는 에러로, 쉽게 try...catch 에서 잡히는 에러를 의미합니다. JS 에서는 런타임 오류를 예외라고 부른다.

<br/>

### JS 의 타입 관련 에러

JS 는 동적 타입 언어이기 때문에 런타임에 타입이 결정되고, 모든 에러가 런타임 환경에서 사용할 때 발생할 수 있다. 최악의 경우 어플리케이션을 작동시킬 때 에러를 확인할 수 도 있다.

컴파일 환경에서 타입에 관련된 에러를 잡을 수 있는 TypeScript 의 도움을 받을 수 있다. 하지만 TS 도 결국 JS 의 superset 이기 때문에 완벽하게 type 에 대한 에러처리를 할 수 있는 것은 아니다. TS 만 쓰면 문제가 없다기 보다는, TS 를 잘 사용한다면 런타임 전에 미리 알 수 있는 오류를 확인할 수 있다는 정도로 이해하면 될 것 같다. 따라서 TS 를 학습할 때, 이러한 에러를 방지할 수 있는 방어코드를 작성하는 습관을 기르는 것을 중점으로 두고 학습해야할 것 같습니다.

<br/>

### 예외와 에러 핸들링

**`예외`**는 일반적으로 런타임 오류와 관련된 것으로 예상하기 어렵거나 예상이 불가능한 이슈를 의미합니다. 이러한 예외가 발생하면 JS 는 `에러 객체`를 내보내고, 처리를 하지 않았다면 프로그램이 종료됩니다.

오류가 발생할 수도 있고 아닐 수도 있는 것을 예외 구문으로 처리하여 프로그램이 예상치 못하게 종료되거나 제 기능을 못하는 것을 방지해야합니다. 따라서 **예외로 인해 발생한 에러 객체를 핸들링하는 것**을 `에러 핸들링`이라고 합니다. JS 의 에러는 런타임 환경에서의 에러, 즉 예외를 의미하여 사용하기도 합니다.

<br/>

### 에러 핸들링은 왜 필요할까?

사용자가 특정 페이지에 진입을 시도했을 때, 계속 Spinner 가 돌고 있다면? 사용자는 부정적인 경험을 할 것입니다. 그리고 이 기능이 DB 와 연관이 있다면, 서비스의 트렌젝션에 영향을 미쳐 장애를 일으킬 수도 있습니다. 따라서 에러 핸들링을 통해 **사용자가 부정적인 경험을 하지 않고**, **장애를 일으킬 수 있는 상황이 발생하는 것을 막을 수 있습니다.**

<br/>

### 에러의 분류

크게 2가지 기준으로 총 4가지로 분류할 수 있습니다. 하지만 명확한 구분은 어렵기 때문에 프로젝트 상황에 맞게 판단하면 됩니다.

- 예상 가능한 에러, 예상 불가능한 에러
- 사용자 입장에서 해결이 가능한 에러, 해결이 불가능한 에러

예상이 가능한 에러에 대한 예시는 다음과 같습니다.

- 인증에러
- 없는 페이지를 접근했을 때의 에러
- 어플리케이션에서 정의한대로 API 응답의 상태 코드로 예측할 수 있는 에러
- 악의적인 목적으로 접근했을 때 이를 보완하는 코드가 프로그램에 내재되어있지 않은 경우

예상이 불가능한 에러에 대한 예시는 다음과 같습니다.

- 서비스 장애
- 일시적인 네트워크가 불안정한 상황에서 발생하는 에러
- 500대 에러

<br/>

### **Try-catch-finally**

try - catch - finally 에 대해서 다시 한 번 짚고 넘어가 봅시다.

- `Try`

  에러가 발생할 수도 있는 로직 작성합니다. 에러를 직접 throw 할 수도 있습니다.

  에러 객체는 네임과 메시지라는 주요 프로퍼티를 가진 객체입니다.

- `Catch`

  에러 객체를 인자로 받습니다.

- `Finally`

  로직의 성공 & 실패 여부와 상관없이 무조건 실행되는 부분입니다.

## 에러 핸들링 예시

### 예상할 수 있는 에러

비동기 API 통신에서의 에러핸들링을 예시로 다뤄보자. 400 번 상태 코드를 받는다면 요청 오류, 500 번 상태 코드는 서버 오류이다. 상태 코드를 통해 예외 상황을 분류할 수 있다. 하지만 하나의 상태 코드는 다양한 상황이 있을 수 있다. 에러 코드와 에러 메세지를 통해 명확하게 알려줄 수 있다. 에러 코드는 보통 상태 코드와 커스텀한 문자열 또는 번호를 의미한다.

다음은 오류의 응답에 대한 컨벤션이다. 보다 정확한 오류의 원인에 따라 사용자에게 가이드를 할 수 있고, 개발자의 입장에서도 쉽게 모니터링을 할 수 있다.

```jsx
{
  "error": {
    "message": "Message describing the error",
    "type": "OAuthException",
    "code": 190,
    "error_subcode": 460,
    "error_user_title": "A title",
    "error_user_msg": "A message",
    "fbtrace_id": "EJplcsCHuLu"
  }
}
```

다음은 Facebook 의 개발자 문서에 나오는 에러 객체의 key 값들에 대한 설명입니다.

- `message`: 읽을 수 있는 오류 설명입니다.
- `code`: 오류 코드입니다. 일반적인 값이 일반적인 복구 방법과 함께 아래에 나열되어 있습니다.
- `error_subcode`: 오류에 대한 추가 정보입니다. 일반적인 값이 아래에 나열되어 있습니다.
- `error_user_msg`: 사용자에게 표시되는 메시지입니다. 메시지의 언어는 API 요청의 로캘을 기반으로 합니다.
- `error_user_title`: 대화 상자의 제목입니다(표시되는 경우). 메시지의 언어는 API 요청의 로캘을 기반으로 합니다.
- `fbtrace_id`: 내부 지원 식별자입니다. 그래프 API 호출과 관련된 [버그를 보고](https://developers.facebook.com/bugs/)할 때 `fbtrace_id`를 포함하면 디버그를 위한 로그 데이터를 찾는 데 도움이 됩니다.

### 예상할 수 없는 에러

- 일시적인 에러임을 알리기
- 고객센터에 연락할 수 있는 창구를 마련하기
- 개발환경에서는 콘솔 에러를 통해 확인하고, 배포환경에서는 센트리 등의 도구를 활용해 로깅할 수 있다.

## 에러 핸들링에 대한 고찰

### 무조건 try-catch 하는 것을 지양하자.

사용자에게 에러를 보여주지 않기 위해 에러의 가능성이 있는 코드에 대해서 예외처리를 하면 될까요?
무작정 트라이 캐치를 하는 것을 지양하라고 합니다. 그 이유는 다음과 같다.
먼저, catch 에 넘어가는 에러가 분기 처리하지 않으면 무엇인지 명확하게 알 수 없습니다.
두 번째로 모든 예외 상황에 대해 catch 한다면 사용자에게는 에러가 보이지 않겠지만 이는 오류를 해결하는 것이 아니라 숨기는 것에 불과합니다. 따라서 안좋은 쪽으로 프로그램을 만들 수도 있습니다.
마지막으로 try-catch 문을 중첩으로 사용하거나, catch 안에서 rethrow 를 하는 경우 어플리케이션이 커진다면 가독성이 매우 떨어집니다.

따라서 성공하는 여부에 대해서만 다루고, 실패하는 경우는 외부에 위임하는 방법을 선택할 수 있습니다. React Suspense 와 Error Boundary 도 이러한 맥락에서 등장한 개념이라고 생각하면 될 것 같습니다. Error 처리에 대해서는 Error Boundary 로 위임하여 선언적으로 에러를 핸들링하는 것이 가능해집니다.

다음 두 개의 함수에 대한 예시를 살펴보겠습니다.

```jsx
const checkAuth = async accessToken => {
  const user = await login(accessToken)
  const role = await getRole(user)
  return roel
}

const UserPage = () => {
  try {
    checkAuth(accessToken)
  } catch (error) {
    console.error(ERROR_MESSAGE(error.code) ?? ERROR_MESSAGE.DEFAULT)
  }
}
```

AccessToken 에서 오류가 없다면 실제 checkAuth 에서 오류가 날 일이 적어집니다. 필요에 의해서 checkAuth 안에서 예외 처리를 하기도 하지만, 환경에 의해서는 엑세스 토큰이 절대 오류가 나지 않는 개발자에게는 불필요한 코드를 작성할 수도 있습니다. 외부로 실패하는 상황을 위임하여, 더불어 다양한 방법으로 에러 핸들링할 때 유지보수성을 높일 수 있도록 하는 것이 유용한 방법입니다.

따라서 우리는 유의미한 에러를 내보낼 수 있는 범위에서 에러 핸들링해야합니다. 그리고 만약 유의미한 결과를 내보낼 수 없다면 에러를 터뜨리는 것이 더 유용할 수 있습니다. 서비스의 미래를 위해 에러를 터트리고, 추후에 모니터링을 통해 에러의 원인을 찾아내는 것이 유지보수를 위해 중요합니다.
