---
title: '2021 하반기 프로그래머스 FE과제 리뷰(2)'
date: 2022-03-10 20:30:00
category: 'FrontEnd'
draft: false
---

이번 글에서는 helper 함수, 컴포넌트 설계와 리스트 페이지 구현을 다뤄보려고한다.
저번 글과 달리 코드를 먼저 작성하고 그 코드에 대해서 설명하는 방식으로 작성하려고 한다.

## 1. helper 함수

```jsx
// utils/helper.js
export const qs = (selector, scope = document) => {
  if (!selector) throw 'no selector'
  return scope.querySelector(selector)
}

export const qsAll = (selector, scope = document) => {
  if (!selector) throw 'no selector'
  return scope.querySelectorAll(selector)
}

export const log = console.log

export const createComma = price => price.toLocaleString('ko-KR')

export const isTarget = (selector, scope, target) => {
  const children = [...qsAll(selector, scope)]
  return children.includes(target) || target.closest(selector)
}
```

- `qs & qsAll`

JS 로 DOM 에 접근하는 경우에는 `querySelector`, `querySelectorAll` **DOM API** 를 자주사용한다. scope 로는 defaultValue 를 할당하고 필요한 경우에만 사용한다. 개발환경에서 잘못된 `selector` 선택하는 휴먼 에러를 방지하기 위해서 다음과 같이 작성해준다.

- `log()`

`console.log` 는 개발할 때 정말 많이 사용한다. `log` 라는 함수로 작성해서 사용하다보면 그래도 10글자보다는 짧기 때문에 개발 효율성을 조금이나마 올려주는 것 같다.

- `createComma(price)`

이번 문제에서는 모든 금액에 대해서는 3자리마다 `,` 를 찍어서 표시하라고 명시되어있다. `price` 라는 변수를 받아서 이를 문자열로 암시적 변환을 하고, 문자열이 갖는 내장 메서드인 `toLocaleString` 를 사용해준다.

- `isTarget (selector, scope, target)`

해당 이벤트가 원하는 target 인지를 반환하는 함수이다. 이벤트 버블링을 활용한 이벤트 위임을 구현하기 위한 함수이다.

## 2. 컴포넌트 설계

이제 컴포넌트를 설계해보자. 현 시점의 웹 어플리케이션이 컴포넌트 단위로 설계되고 개발되고 있기 때문에 VanillaJS 로 구현할 때도 이 아이디어에 착안해서 개발하는데 더 익숙해졌다. 컴포넌트 설계의 기반이 되는 순서는 다음과 같다.

```jsx
# 초기 렌더링
initialState - render

# 상태 변화에 따른 렌더링
state - setState - render
```

컴포넌트는 `state` 를 갖고 이를 기반으로 브라우저에 출력된다. 초기 렌더링도 초기 상태인 `initialState` 에 기반해 렌더링된다.

이 코드의 핵심은 다음과 같다.

- `state` 가 변경되면 `render` 를 실행한다.
- `state` 는 `setState` 로만 변경해야 한다.

이제 코드를 살펴보자.

```jsx
export default class Component {
  $target
  state
  constructor($target, props) {
    this.$target = $target
    this.props = props
    this.setInitialState()
    this.render()
    this.setEvent()
  }
  setInitialState() {
    this.state = {
      _TAG: 'IDLE',
      data: [],
    }
  }
  setState(newState) {
    this.state = { ...this.state, ...newState }
    this.render()
  }
  template() {}
  render() {
    this.$target.innerHTML = this.template()
  }
  mounted() {
    // 자식 컴포넌트를 추가해준다.
  }
  setEvent() {
    //eventListener 를 추가해준다.
  }
  addEvent(scope, eventType, callback, selector) {
    scope.addEventListener(eventType, event => {
      // if(!isTarget(selector, scope, event.target)) return false;
      callback(event)
    })
  }
}
```

- `constructor($target, props)`

`constructor` 메서드는 class 로 생성된 객체를 생성하고 초기화한다.

`$target` 은 `innerHTML` 의 `Element` 를 지정하기 위해서 사용한다.

```jsx
const $target = document.querySelector('.APP')
$target.innerHTML = `<div>target</div>`
```

이를 통해 `element` 의 내용을 변경하는데 유용하게 사용할 수 있다. 특히 기존에 존재하는 `element` 를 덮어쓸 수 있어 `element` 의 내용을 지워줄 필요가 없다.

범용성이 높기 때문에 단점도 갖고 있다. 이는 `<script>` 태그 삽입으로 인한 크로스 사이트 스크립트 공격에 취약하기 때문에 사용에 주의해야한다는 점을 인지하고 사용하면 더 좋을 것 같다. 이에 대한 대안으로는 `insertAdjacentHTML` 속성이 있고 `innerHTML` 과 달리 덮어쓰기를 할 수는 없는 속성이다. 이에 대해서는 기존에 있던 `Element` 를 삭제해야한다.

- `setInitialState()`

초기 상태를 지정하는 메서드이다. `_TAG` 속성을 사용해 컴포넌트의 현재 상태를 구분한다. `_TAG` 는 `IDLE, LOADING, OK, ERROR` 4가지 값을 가질 수 있으며 이는 **HTML문자열**을 반환하는 `template` 함수에서 \_TAG 를 기반으로 렌더링하도록 작성해줄 예정이다.

- `setState(newState)`

```jsx
setState(newState){
        this.state = {...this.state, ...newState};
        this.render();
}
```

새로운 상태를 받아서 상태를 변경시키는 함수이다. 기존 상태를 복사하고 새로운 상태를 주입한다.

위에서 언급한 상태가 변화한다면 `render` 함수를 실행시킨다.

- `template()`

HTML 문자열을 반환하는 함수이다. 상태에 맞는 **HTML문자열**을 반환하도록 작성한다. 이번 과제에서는 명시되지 않았지만, 종종 LOADING 상태 스피너를 보여줘야하는 요구사항이 있기 때문에 분기처리해주는 편이다.

```jsx
template (){
        const {_TAG, data} = this.state;
        switch (_TAG){
          case 'IDLE':
            return `<div class="ProductListPage">IDLE</div>`;
          case 'LOADING':
            return `<div class="ProductListPage">LOADING</div>`;
          case 'ERROR':
            return `<div class="ProductListPage">ERROR</div>`;
          case 'OK':
            return `
                <div class="ProductListPage">
                //...
                </div>
            `
          default:
            return;
        }
    }
```

- `mounted()`

mount 는 자식 컴포넌트가 있는 경우 이를 클래스의 인스턴스 속성인 `children` 으로 저장하기 위해 사용한다. 계층구조의 경우에 자식 컴포넌트의 상태에 접근해야할 경우가 있기 때문에 지정해준다.

- `setEvent()`

`setEvent` 는 `addEvent` 함수를 실행시켜주는 메서드이다. 실질적은 이벤트 리스너를 추가해주는 역할은 `addEvent` 에서 수행한다.

- `addEvent(scope, eventType, callback, selector)`

```jsx
addEvent(scope, eventType, callback, selector){
    scope.addEventListener(eventType, event => {
				// if(!isTarget(selector, scope, event.target)) return false;
        callback(event);
    })
}
```

먼저 `scope` 와 `eventType` 를 인자로 받는다. `scope` 는 대부분 해당 컴포넌트의 `$target` 으로 설정된다. 이벤트 위임을 사용할 것이기 때문에 최대한 상위 DOM 에서 이벤트를 걸어준다.

다음은 `callback` 이며 이는 이벤트 발생시 핸들링할 함수를 작성해준다. 마지막 `selector` 는 원하는 event target 을 가진 selector 를 인자로 받는다. 이는 이벤트 버블링을 활용한 이벤트 위임을 활용할 때만 받는 인자이며 그 때는 주석처리한 isTarget 을 주석해제해주고 사용한다.

다음은 `ProductListPage` 에서 사용하는 이벤트 위임 방식 예제코드이다. 기존 `target` 에서부터 `.Product` 클래스명을 갖는 선택자까지 탐색한다. 만약 해당 `target` 이 존재하지 않는다면 `callback` 함수가 실행되지 않고 조건을 만족한다면 해당 `callback` 함수를 실행한다.

```jsx
setEvent(){
	this.addEvent(qs('.ProductListPage'), 'click', ({target}) => {
    const productId = target.closest('.Product').dataset.id
    goNextPage(`/web/products/${productId}`);
	}, '.Product');
}

addEvent(scope, eventType, callback, selector){
    scope.addEventListener(eventType, event => {
				if(!isTarget(selector, scope, event.target)) return false;
        callback(event);
    })
}
```

## 3. API 호출 함수

```jsx
// network/index.js
export const getAllProducts = async () => {
  const response = await fetch(
    'https://uikt6pohhh.execute-api.ap-northeast-2.amazonaws.com/dev/products'
  )
  let data
  if (response.ok) data = await response.json()
  else throw Error('NETWORK ERROR')

  return data
}

export const getProductById = async productId => {
  const response = await fetch(
    `https://uikt6pohhh.execute-api.ap-northeast-2.amazonaws.com/dev/products/${productId}`
  )
  let data
  if (response.ok) data = await response.json()
  else throw Error('NETWORK ERROR')

  return data
}
```

API 호출함수 코드이다. 모든 아이템 리소스를 받아오는 함수와 id 에 해당하는 리소스를 받아오는 함수를 `fetch API` 를 활용해 작성했다.

## 4. ProductListPage

`ProductListPage` 컴포넌트를 작성해주기 전에 페이지 이동을 구현하는 메서드를 작성하자. `history API` 의 `pushState` 메서드를 활용해 페이지 이동을 구현할 수 있다. `pushState` 는 브라우저의 세션 기록 스택에 상태를 추가하는 메서드이기 때문이다. 다음은 `pushState` 에 대한 간략한 설명이다.

```jsx
history.pushState(state, title[, url]);

state - 새로운 세션 기록 항목에 연결할 상태 객체이다.
title - 지금은 사용되지 않지만 나중에 사용될 수 있고, 상태에 대한 짧은 제목을 제공할 수 있다.
url - 변경될 url이며 출처는 동일해야한다.
// forward, back, go, pushState, replaceState
```

`history API`는 `SPA` 에서 페이지 이동을 구현할 때 반드시 필요하기 때문에 잘 이해할 필요가 있다. 다음은 [링크](https://developer.mozilla.org/ko/docs/Web/API/History_API)는 MDN 의 history API 에 대한 설명이다

이를 활용해 다른 페이지로 이동하는 함수를 구현할 수 있다. 이 때 `pushState()` 메서드는 `popstate` 이벤트를 발생시키지 않기 때문에 `router()` 함수를 한 번 더 호출해줘야한다.

```jsx
//router/index.js
//...
export const goNextPage = url => {
  history.pushState(null, null, url)
  router()
}
```

이제 `ProductList` 클래스를 만들어보자. 위에서 작성한 `Component` 를 상속해서 만든다.

```jsx
//pages/ProductList.js
import Component from '../common/Component.js'
import { getAllProducts } from '../network/index.js'
import { qs, isTarget } from '../utils/helper.js'
import { goNextPage } from '../router/index.js'

export default class ProductList extends Component {
  template() {
    const { _TAG, data } = this.state
    switch (_TAG) {
      case 'IDLE':
        return `<div class="ProductListPage"></div>`
      case 'LOADING':
        return `<div class="ProductListPage">LOADING</div>`
      case 'OK':
        return `
                <div class="ProductListPage">
                    <h1>상품목록</h1>
                    <ul>
                    ${data.map(
                      item => `
                        <li class="Product" data-id=${item.id}>
                            <img src=${item.imageUrl} alt="productimage" />
                            <div class="Product__info">
                                <div>${item.name}</div>
                                <div>${item.price.toLocaleString(
                                  'ko-KR'
                                )}원</div>
                            </div>
                        </li>`
                    )}
                    </ul>
                </div>
            `
      default:
        return
    }
  }
  setEvent() {
    this.addEvent(
      qs('.ProductListPage'),
      'click',
      ({ target }) => {
        const productId = target.closest('.Product').dataset.id
        goNextPage(`/web/products/${productId}`)
      },
      '.Product'
    )
  }
  addEvent(scope, eventType, callback, selector) {
    scope.addEventListener(eventType, event => {
      if (!isTarget(selector, scope, event.target)) return false
      callback(event)
    })
  }
  async getProductList() {
    this.setState({ _TAG: 'LOADING' })
    try {
      const data = await getAllProducts()
      this.setState({ data, _TAG: 'OK' })
      this.setEvent()
    } catch (e) {
      this.setState({ _TAG: 'ERROR' })
    }
  }
}
```

- `template()`

`_TAG` 의 상태에 기반해서 반환한다. `OK` 상태인 경우 해당 **HTML문자열**을 반환한다.

- `setEvent()`

`addEvent()` 메서드를 실행시킨다. 이 페이지에서 핸들링할 이벤트는 상품 목록을 클릭했을 때 해당 페이지로 이동하는 것이기 때문에 해당 이벤트를 핸들링하는 함수를 추가해준다.
위에서 잠깐 다뤘지만 이벤트 위임을 활용하기 때문에 `isTarget` 함수를 불러와서 활용한다.

- `addEvent()`

컴포넌트 설명할 때 다룬 내용과 다르지 않기 때문에 생략한다!

- `getProductList()`

상품 목록 리소스를 가져오는 메서드이다. 비동기 요청을 하기 때문에 함수명 앞에 `async` 를 붙여준다. 먼저 해당 상태를 `Loading` 으로 변경시킨다. 그리고 data 를 받아온다.
`ES2017` 에 등장한 `async-await` 키워드를 사용한 경우에 코드가 동기적으로 동작한다. 따라서 데이터를 받아오고 이를 기반으로 상태를 최신화한다.
다음으로 `setEvent()` 메서드를 실행해준다. `template()` 에서 반환하는 값이 상태 기반이기 때문에 `template()` 의 반환값이 다르다면 이에 대해 다시 `addEventListener()` 를 실행시켜줘야한다.

## 5. Router 에서 ProductList 객체 생성하기

class 로 컴포넌트를 작성했다고 화면에 나타나지 않는다. 이를 `new` 연산자와 함께 호출해 객체로 만들어야한다. 이전 글에서 작성한 `router` 에서 해당 객체를 만들어주자.

switch-case 문을 작성했던 곳에 다음 코드를 추가해주자.

```jsx
import ProductList from '../pages/ProductList.js'

const $target = qs('.APP')
switch (match.route.path) {
  case '/web/':
    const ProductList = new match.route.view($target)
    ProductList.getProductList()
    break
  case '/web/products/:productId':
  //...
  case '/web/cart':
  //...
  default:
    return
}
```

## EOL(End of Line)

유용하게 사용했던 helper 함수, 컴포넌트 설계, API 호출 그리고 ProductList 컴포넌트까지 작성해봤다.원래 목표는 토요일 시험전까지 글을 완성하는 것이였는데 힘들 것 같다. 남은 내용은 `ProductDetail`, `Cart` 컴포넌트와 `LocalStorage` 활용하기인데, 토요일 시험 후에 천천히 마저 작성해야겠다.

VanillaJS 로 구현하고 내 생각의 흐름을 정리하면서 재미를 느끼고 있는 것 같다. 재미를 느낀만큼 토요일 시험도 잘 보고 싶다 😊

## REFERENCE

- [황준일님 Vanilla Javascript로 웹 컴포넌트 만들기](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Component/#_3-%E1%84%86%E1%85%A9%E1%84%83%E1%85%B2%E1%86%AF%E1%84%92%E1%85%AA)

컴포넌트 설계를 고민할 때 정말 도움을 많이 받았던 글이다. 꼭꼭꼭 읽어봤으면 좋겠다.
