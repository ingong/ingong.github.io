---
title: '[BOJ 14503] 로봇 청소기 (Node.js)'
date: 2022-03-23 12:56:13
category: 'BOJ Code'
draft: false
---

## 문제

[14503번: 로봇 청소기](https://www.acmicpc.net/problem/14503)

## 문제 풀이

구현문제이다. 문제에서 주어진 조건에 맞게 실수없이 구현하면 되는 문제다.

## Recap

- 방향 전환

방향 전환을 index로 처리하는 방법을 활용했다. 크게 방향 전환은 내가 현재 바라보고 있는 방향에서 왼쪽으로 회전하는 경우가 있다. 문제에서는 북은 0, 동은 1, 남은 2, 서는 3으로 지정해줬다.

```jsx
let dir = 0
const dx = [-1, 0, 1, 0]
const dy = [0, 1, 0, -1]
```

현재 북쪽을 바라본다고 가정한다면 왼쪽은 서쪽 방향이다. 이 때는 dir은 3 을 가져야한다. 서쪽에서 한 번 더 왼쪽으로 회전하면 남쪽 방향을 바라보게 되고 이 때 dir 은 2 를 가져야한다. 규칙에 근거해 식을 세워보면 다음과 같다.

```jsx
dir = (dir + 3) % 4
```

나머지 연산자를 활용해 쉽게 방향전환을 할 수 있었다.

- 초기 위치 값 지정

문제의 조건에서 `(r, c)` 를 북쪽에서 r칸, 서쪽에서 c칸 떨어진 위치라고 설명했다. 이는 index가 0부터 시작된다는 의미이다. 첫 번째 열이나 행은 0칸 떨어진 값을 갖기 때문이다. 처음에 착각해서 초기 조건값을 제대로 입력하지 못했고 이를 기억하기 위해 기록해본다.

## Code

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const [N, M] = input[0].split(' ').map(Number)
  const [sx, sy, sd] = input[1].split(' ').map(Number)
  const board = input.slice(2).map(v => v.split(' ').map(Number))
  const dx = [-1, 0, 1, 0]
  const dy = [0, 1, 0, -1]
  const visited = Array.from({ length: N }, () => new Array(M).fill(false))
  const queue = [[sx, sy, sd]]
  visited[sx][sy] = true
  let queueIndex = 0
  while (queueIndex < queue.length) {
    const [x, y, d] = queue[queueIndex]
    let dir = d
    let isCleanable = false
    for (let i = 0; i < 4; i++) {
      dir = (dir + 3) % 4
      const [nx, ny, nd] = [x + dx[dir], y + dy[dir], dir]
      if (nx < 0 || nx > N || ny < 0 || ny > M) continue
      if (board[nx][ny] === 1 || visited[nx][ny] === true) continue
      queue.push([nx, ny, nd])
      visited[nx][ny] = true
      isCleanable = true
      break
    }

    if (!isCleanable) {
      const backDir = (dir + 2) % 4
      const [bx, by] = [x + dx[backDir], y + dy[backDir]]
      if (board[bx][by] === 1) break
      else {
        queue.push([bx, by, dir])
      }
    }

    queueIndex++
  }

  let answer = 0
  for (let row = 0; row < N; row++) {
    for (let col = 0; col < M; col++) {
      if (visited[row][col]) answer++
    }
  }
  log(answer)
}

solution(input)
```
