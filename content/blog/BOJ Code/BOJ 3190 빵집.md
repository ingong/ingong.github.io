---
title: '[백준 3190] 빵집 (Node.js)'
date: 2022-03-11 16:45:13
category: 'BOJ Code'
draft: false
---

## 문제 설명

[3109번: 빵집](https://www.acmicpc.net/problem/3109)

- 그래프 탐색문제이다. 원웅이는 가스를 훔치기 위해 가스관에서 본인의 빵집까지 가스관을 연결시켜야한다.
- 가스관과 빵집을 연결하는 파이프라인의 최대 개수를 구해야한다.

## 문제 풀이

- DFS 문제이다. 맨 왼쪽의 행부터 하나씩 DFS 를 호출한다.
- 파이프가 놓여져있는지 확인하기 위해 visited 배열을 사용한다.
- answer 라는 변수를 활용해 본인의 기준 이전 index에 대해 조건이 만족된다면 탐색하지 않는다.
- 3가지 방향에 대해서 탐색할 수 있고 오른쪽위, 오른쪽, 오른쪽아래 순으로 탐색하는데 만약 오른쪽위에 대한 탐색이 성공적으로 종료되었다면 오른쪽부터는 탐색을 진행하지않는다.

## 문제 회고

- 오랜만에 DFS 문제를 풀었다. BFS 의 방문처리와 혼동이 있어서 방문처리해주는 코드에서 오류가 있었다.
- 문제에 대한 접근은 괜찮았던 것 같다. 그리디는 문제들을 반복적으로 풀고 사고 과정과 접근법을 기억해야한다. 꾸준히 풀자.

## 소스코드

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const [R, C] = input[0].split(' ').map(Number)
  const board = input.slice(1).map(v => v.split(''))
  const visited = Array.from({ length: R }, () => new Array(C).fill(false))
  const dx = [-1, 0, 1]
  const dy = [1, 1, 1]
  let count = 0
  let answer = false

  for (let row = 0; row < R; row++) {
    answer = false
    DFS(row, 0) // error
  }

  function DFS(row, col) {
    visited[row][col] = true // error

    if (col === C - 1) {
      answer = true
      count++
      return
    }

    for (let i = 0; i < 3; i++) {
      const [nx, ny] = [row + dx[i], col + dy[i]]
      if (nx < 0 || nx >= R || ny < 0 || ny >= C) continue
      if (board[nx][ny] === 'x') continue
      if (visited[nx][ny]) continue
      DFS(nx, ny)
      if (answer) return
    }
  }

  log(count)
}

solution(input)
```
