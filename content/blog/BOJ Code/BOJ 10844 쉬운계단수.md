---
title: '[백준 10844] 쉬운 계단 수 (Node.js)'
date: 2022-03-15 13:00:00
category: 'BOJ Code'
draft: false
---

## 문제

[10844번: 쉬운 계단 수](https://www.acmicpc.net/problem/10844)

## 문제 접근

2차원 DP 배열을 선언 후 문제에 접근했다. 각 자리의 숫자가 등장하는 개수를 기준으로 DP 배열을 선언했다.

가지치기로 각각의 숫자로 인해 등장할 수 있는 숫자를 count 하는 방식으로 접근했다.

예를 들면 1의 자리에서는 0 은 존재하지 않고, 나머지 숫자들은 모두 1 씩 존재한다.

십의 자리에서는 0, 1, 9 가 하나씩 등장하고 나머지 숫자는 2번씩 등장한다.

```jsx
10의자리   1의자리

	1       0, 2
	2       1, 3
	3       2, 4
	4       3, 5
	5       4, 6
	6       5, 7
	7       6, 8
	8       7, 9
	9        8
```

10의 자리 숫자가 1 이라면 본인 기준 하나 적은 자리 수에는 0 과 2 가 올 수 있다. 2 라면 1 과 3 이 올 수 있다.

결국 이전 자리의 숫자의 개수가 몇개이냐에 따라서 다음 자리 수에 등장할 수 있는 수의 개수가 결정된다.

| N \ 자릿수 | 0       | 1           | 2           | 3         | 4    | 5    | 6    | 7    | 8           | 9       |
| ---------- | ------- | ----------- | ----------- | --------- | ---- | ---- | ---- | ---- | ----------- | ------- |
| 1          | 0(A)    | 1(B)        | 1(C)        | 1(D)      | 1(E) | 1(F) | 1(G) | 1(H) | 1(I)        | 1(J)    |
| 2          | 1 = (B) | 2 = (A + C) | 2 = (B + D) | 2 = C + E |      | ...  | ...  | .... | 2 = (H + J) | 1 = (I) |

점화식을 세워보면 다음과 같다.

```jsx
DP[N][K] = DP[N - 1][K - 1] + DP[N - 1][K + 1]

여기서 K 가 0 이거나 9 일 때는 범위를 벗어나기 때문에
if(K === 0) DP[N][K] = DP[N - 1][1]
else if(K === 9) DP[N][K] = DP[N - 1][8]
```

## 문제 회고

정답률이 높지 않았는데 끝까지 생각해내서 문제를 풀 수 있었다. 규칙을 찾기 위해서는 나열하는 방식을 통해 규칙을 찾는 것도 충분히 방법이 될 수 있으며 꾸준하게 문제를 풀어야겠다는 생각을 하게 됐다.

## 소스 코드

```jsx
// BAEKJOON
const input = require('fs')
  .readFileSync('/dev/stdin')
  .toString()
  .trim()
  .split('\n')
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
// const input = require('fs').readFileSync('TESTCASE/index.txt').toString().trim().split('\n');
const log = console.log

const solution = input => {
  const N = +input[0]
  const DP = Array.from({ length: N }, () => Array(10).fill(0))
  // 1의 자리
  for (let i = 1; i < 10; i++) {
    DP[0][i] = 1
  }
  // 10의 자리 이상
  for (let row = 1; row < N; row++) {
    for (let col = 0; col < 10; col++) {
      if (col === 0) DP[row][col] = DP[row - 1][1] % 1000000000
      else if (col === 9) DP[row][col] = DP[row - 1][8] % 1000000000
      else
        DP[row][col] =
          (DP[row - 1][col - 1] + DP[row - 1][col + 1]) % 1000000000
    }
  }
  log(DP[N - 1].reduce((acc, cur) => acc + cur, 0) % 1000000000)
}

solution(input)
```
