---
title: '[BOJ 14891] 톱니바퀴 (Node.js)'
date: 2022-03-20 14:56:13
category: 'BOJ Code'
draft: false
---

## 문제

[14891번: 톱니바퀴](https://www.acmicpc.net/problem/14891)

## 문제 풀이

톱니바퀴의 현재 상태를 리스트로 관리한다. 그리고 문제에서 주어진 회전 리스트를 순회하면서 조작한다. 회전하는 톱니바퀴의 좌측 톱니에 대해서는 좌측에 위치한 톱니바퀴의 우측 톱니와 비교하고, 톱니바퀴의 우측 톱니에 대해서는 우측에 위치한 톱니바퀴의 좌측 톱니와 비교한다. 이 때 해당 값이 다르다면 회전을 시키고 이 회전은 또 해당 방향으로 전파된다. 만약 같다면 해당 톱니는 회전하지 않는다.

극단을 기준으로 생각하면 맨 우측의 톱니가 회전을 시작할 때는 최대 3개의 톱니바퀴가 회전이 가능하다. 즉, 왼쪽 오른쪽에 대해서 최대 3개의 톱니바퀴를 회전시킨다고 가정하고 문제를 풀이했다.

## 문제 회고

Simulation 문제인데 좀 더 깔끔한 풀이는 없을까 고민하다가 시간을 소요했다. 지금 이렇게 고민하는 포인트가 맞는지는 잘 모르겠지만 꾸준히 풀면서 이러한 사고방식 능력이 향상된다고 생각해야할 것 같다.

특히, 처음에는 queue에 넣고 BFS느낌으로 풀려고 했는데 잘못된 풀이였다. 최근에 알고리즘을 많이 풀면서 조금 실력이 늘었다고 생각을 했고, 자만심을 가졌다는 것을 이번 문제를 풀면서 느꼈다. 다시 한 번 나를 반성하게 됏다. 구현 문제의 경우에는 풀기 전에 구현사항을 손으로 구현하면서 설계를 해야하는데 그냥 풀기 시작한 지점이 잘못되었던 것 같다.

## 소스코드

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const toothList = input.slice(0, 4).map(v => v.split('').map(Number))
  const K = +input[4]
  const rotationList = input.slice(5).map(v => v.split(' ').map(Number))

  for (const [tooth, rotate] of rotationList) {
    const queue = []
    const [LEFT, RIGHT] = [6, 2]
    const targetIndex = tooth - 1
    queue.push([targetIndex, rotate])

    // 1 번이라고 가정했을 때 (총 3번 순회) =>
    let [tempRightIndex, tempRotate] = [targetIndex, rotate]
    let rightCount = 1
    while (rightCount < 4) {
      const nIndex = tempRightIndex + 1
      if (nIndex >= 4) break
      if (toothList[tempRightIndex][RIGHT] === toothList[nIndex][LEFT]) break
      queue.push([nIndex, -tempRotate])
      tempRotate = tempRotate * -1
      tempRightIndex = nIndex // error
      rightCount++
    }

    // 4 번이라고 가정했을 때 (총 4번 순회) <=
    let [tempLeftIndex, tempLeftRotate] = [targetIndex, rotate]
    let leftCount = 1
    while (leftCount < 4) {
      const nIndex = tempLeftIndex - 1
      if (nIndex < 0) break
      if (toothList[tempLeftIndex][LEFT] === toothList[nIndex][RIGHT]) break
      queue.push([nIndex, -tempLeftRotate])
      tempLeftRotate = tempLeftRotate * -1
      tempLeftIndex = nIndex
      leftCount++
    }

    for (const [index, rotate] of queue) {
      if (rotate === 1) rotateClockWise(index)
      else rotateCounterClockWise(index)
    }
  }

  let answer = 0
  for (let i = 0; i < 4; i++) {
    if (toothList[i][0] === 0) continue
    else answer = answer + 2 ** i // error
  }
  log(answer)

  function rotateClockWise(index) {
    const target = toothList[index]
    const lastElement = target.pop()
    toothList[index] = [lastElement, ...target]
  }

  function rotateCounterClockWise(index) {
    const target = toothList[index]
    const firstElement = target.shift()
    toothList[index] = [...target, firstElement]
  }
}

solution(input)
```
