---
title: '[백준 1922] 네트워크 연결 (Node.js)'
date: 2022-03-17 12:08:13
category: 'BOJ Code'
draft: false
---

## 문제

[1922번: 네트워크 연결](https://www.acmicpc.net/problem/1922)

## 문제 풀이

크루스칼 알고리즘을 활용해 MST(최소스패닝트리)를 생성하는 문제다. Union-find 알고리즘을 활용해 집합을 대표하는 원소 변경과 사이클을 생성하지 않으면서 MST 를 생성한다.

## 문제 회고

프로그래머스에서 풀었던 섬 연결하기 문제와 거의 동일하다. 간선이 많은 경우에는 MST 를 생성하기 위해 프림 알고리즘을 사용할 수 있다. 프림 알고리즘도 자주 사용되지는 않지만 관련된 문제를 풀어봐야겠다.

## 소스 코드

- 문제 풀이

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const N = +input[0]
  const M = +input[1]
  const costs = input.slice(2).map(v => v.split(' ').map(Number))
  const COST = 2
  costs.sort((a, b) => a[COST] - b[COST])
  const disjointSet = new DisjointSet(N)
  let answer = 0

  for (let i = 0; i < costs.length; i++) {
    const [from, to, cost] = costs[i]
    if (!disjointSet.connected(from, to)) {
      disjointSet.union(from, to)
      answer += cost
    }
  }
  log(answer)
}

solution(input)
```

- DisjointSet

```jsx
class DisjointSet {
  constructor(n) {
    this.parent = Array.from({ length: n + 1 }, (_, i) => i)
  }

  union(n1, n2) {
    const rootA = this.find(n1)
    const rootB = this.find(n2)
    if (rootA < rootB) this.parent[rootB] = rootA
    else this.parent[rootA] = rootB
  }

  find(node) {
    if (this.parent[node] === node) return node
    this.parent[node] = this.find(this.parent[node])
    return this.parent[node]
  }

  connected(n1, n2) {
    if (this.find(n1) != this.find(n2)) return false
    else return true
  }
}
```
