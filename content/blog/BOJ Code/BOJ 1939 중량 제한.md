---
title: '[BOJ 1939] 중량 제한 (Node.js)'
date: 2022-03-24 11:41:13
category: 'BOJ Code'
draft: false
---

## 문제

[1939번: 중량제한](https://www.acmicpc.net/problem/1939)

## 문제 풀이

3가지 방법을 활용해 문제를 풀었다.

1. 이분탐색과 BFS
2. 이분탐색과 DFS
3. DisjointSet

BFS와 DFS로 문제를 풀 때는 해당 중량으로 가상의 트럭을 이동시켰을 때 시작점에서 도착지까지 도착할 수 있는지 여부를 판단한다. 이 때 도착할 수 있다면 중량을 증가시켜도되기 때문에 중량을 늘려준다. DFS의 경우에는 DFS함수 호출을 if문안에서 수행하고 만족한다면 그 때 true를 return하고 false라면 다음 for문을 순회하도록한다.

DisjointSet의 경우에는 시작과 도착 도시를 하나의 그룹으로 만들어주는 방식이다. 먼저 무게가 무거운 순으로 서로 다른 도시를 연결해주는 입력을 정렬한다. 이 쌍을 순회하면서 해당 도시를 연결시켜준다. for 문이 한 번 순회할 때마다 문제에서 주어진 출발과 도착 도시가 연결되어있는지를 확인한다. 연결이 된다면 해당 무게가 문제의 정답이 된다.

## Recap

처음에 문제를 풀 때는 해당 다리의 무게의 값에 최대값만을 갖도록 설정하고 문제를 풀었고, 왜 안되는지 몰랐다. 다음 날 다시 풀어보니 좀 간단한 문제였다. 최대 무게로 설정하면 해당 도시에서는 최대 무게보다 적다면 통과할 수가 없는 것이다.

DFS로 문제를 풀 때는 조금씩 틀을 변경시키면서 풀었던 것 같은데, 이제는 정해진 DFS틀에 맞춰서 문제를 풀어야겠다. 괜히 여러 조건을 변경시키면서 문제를 풀면 헷갈리게 되고 실수도 많아지는 것 같다.

문제를 푸는 순간 딴 생각을 한 번하면 조건을 누락시키는 경우가 있었다. 문제를 풀었다고 자만하지 말고 끝까지 집중해서 문제를 푸는 습관을 기르는 노력이 더 필요한 것 같다.

## Code

1. 이분탐색과 BFS

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const [N, M] = input[0].split(' ').map(Number)
  const array = input.slice(1, -1).map(v => v.split(' ').map(Number))
  const [from, to] = input[input.length - 1].split(' ').map(Number)
  const bridges = Array.from({ length: N }, () => [])
  let maxWeight = 0

  for (const [from, to, weight] of array) {
    bridges[from - 1].push([to - 1, weight])
    bridges[to - 1].push([from - 1, weight])
    if (weight > maxWeight) maxWeight = weight
  }

  const BFS = cost => {
    const visited = new Array(N).fill(false)
    const queue = []
    queue.push(from - 1)
    visited[from - 1] = true
    let queueIndex = 0
    while (queueIndex < queue.length) {
      const city = queue[queueIndex]

      if (city === to - 1) return true
      for (let i = 0; i < bridges[city].length; i++) {
        const [nCity, nCost] = bridges[city][i]
        if (!visited[nCity] && cost <= nCost) {
          visited[nCity] = true
          queue.push(nCity)
        }
      }
      queueIndex++
    }
    return false
  }

  let left = 0,
    right = maxWeight
  while (left <= right) {
    const mid = Math.floor((right + left) / 2)
    if (BFS(mid)) left = mid + 1
    else right = mid - 1
  }
  log(right)
}

solution(input)
```

1. 이분탐색과 DFS

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const [N, M] = input[0].split(' ').map(Number)
  const array = input.slice(1, -1).map(v => v.split(' ').map(Number))
  const [from, to] = input[input.length - 1].split(' ').map(Number)
  const bridges = Array.from({ length: N }, () => [])
  let maxWeight = 0

  for (const [from, to, weight] of array) {
    bridges[from - 1].push([to - 1, weight])
    bridges[to - 1].push([from - 1, weight])
    if (weight > maxWeight) maxWeight = weight
  }

  const DFS = (cost, city, visited) => {
    if (city === to - 1) return true
    visited[city] = true

    for (const value of bridges[city]) {
      const [node, weight] = value
      if (visited[node] || weight < cost) continue
      else {
        if (DFS(cost, node, visited)) return true
        else continue
      }
    }

    return false
  }

  let left = 0,
    right = maxWeight
  const visited = new Array(N).fill(false)
  while (left <= right) {
    const mid = Math.floor((right + left) / 2)
    visited.fill(false)

    if (DFS(mid, from - 1, visited)) left = mid + 1
    else right = mid - 1
  }
  log(right)
}

solution(input)
```

1. DisjointSet

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const [N, M] = input[0].split(' ').map(Number)
  const array = input.slice(1, -1).map(v => v.split(' ').map(Number))
  const [start, end] = input[input.length - 1].split(' ').map(Number)
  const bridgesList = []

  for (const [from, to, weight] of array) {
    bridgesList.push({ from, to, weight })
  }
  bridgesList.sort((a, b) => b.weight - a.weight)

  let answer = 0
  const disjointSet = new DisjointSet(N + 1)
  for (let i = 0; i < bridgesList.length; i++) {
    const { from, to, weight } = bridgesList[i]
    disjointSet.union(from, to)
    answer = weight
    if (disjointSet.connected(start, end)) break
  }
  log(answer)
}

solution(input)
```
