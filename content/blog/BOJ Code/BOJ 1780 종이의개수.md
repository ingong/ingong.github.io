---
title: '[BOJ 1780] 종이의 개수 (Node.js)'
date: 2022-03-25 13:07:13
category: 'BOJ Code'
draft: false
---

## 문제

[1780번: 종이의 개수](https://www.acmicpc.net/problem/1780)

## 문제 풀이

분할 정복 유형의 문제이다. 재귀호출을 통해 문제를 풀었다. DFS호출 시 x, y 좌표와 size를 인자로 전달한다. 처음에는 전체 크기를 size로 전달한다. 종료조건은 크게 2가지로 나뉜다. 먼저, 크기가 1인 경우이다. 이 경우에는 더 이상 탐색이 불가능하기 때문에 해당하는 숫자만큼 answer에 값을 증가시켜준다. 두 번째는 서로 다른 숫자를 가지는 경우이다. 먼저 3가지 원소에 대한 boolean값을 갖는 변수를 선언한다. 해당하는 모든 board의 원소를 탐색해서 해당 원소를 제외하고는 다른 원소가 불가능하다는 것을 표시한다. 왜냐하면 하나의 원소로 통일되는 경우밖에 존재하지 않기 때문이다. 만약 해당 변수의 boolean값이 참이라면 해당 answer에 갯수를 1더해주고 DFS호출을 종료한다.

## Recap

처음으로 풀어본 분할정복문제이다. 감이 안잡혀서 [해당 블로그](https://yabmoons.tistory.com/452) 를 참고해서 풀었다. 분할정복 유형을 아직까지 한번도 코딩테스트에서 접해보지는 못했는데 그래도 해당 유형에 대한 문제도 꾸준하게 풀어봐야겠다.

## Code

```tsx
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const N = +input[0]
  const board = input.slice(1).map(v => v.split(' ').map(Number))
  const answer = new Array(3).fill(0)

  const DFS = (x, y, size) => {
    if (size === 1) {
      answer[board[x][y] + 1]++
      return
    }

    let zero = true,
      minus = true,
      plus = true
    for (let i = x; i < x + size; i++) {
      for (let j = y; j < y + size; j++) {
        if (board[i][j] === -1) {
          zero = false
          plus = false
        } else if (board[i][j] === 0) {
          minus = false
          plus = false
        } else if (board[i][j] === 1) {
          minus = false
          zero = false
        }
      }
    }

    if (minus) {
      answer[0]++
      return
    }
    if (zero) {
      answer[1]++
      return
    }
    if (plus) {
      answer[2]++
      return
    }

    const nextSize = Math.floor(size / 3)
    DFS(x, y, nextSize)
    DFS(x, y + nextSize, nextSize)
    DFS(x, y + nextSize * 2, nextSize)

    DFS(x + nextSize, y, nextSize)
    DFS(x + nextSize, y + nextSize, nextSize)
    DFS(x + nextSize, y + nextSize * 2, nextSize)

    DFS(x + nextSize * 2, y, nextSize)
    DFS(x + nextSize * 2, y + nextSize, nextSize)
    DFS(x + nextSize * 2, y + nextSize * 2, nextSize)
  }
  DFS(0, 0, N)
  for (let i = 0; i < answer.length; i++) {
    log(answer[i])
  }
}

solution(input)
```
