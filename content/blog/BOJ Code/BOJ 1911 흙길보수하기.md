---
title: '[백준 1911] 흙길 보수하기 (Node.js)'
date: 2022-03-17 15:33:13
category: 'BOJ Code'
draft: false
---

## 문제

[1911번: 흙길 보수하기](https://www.acmicpc.net/problem/1911)

## 문제 풀이

물웅덩이를 지나기 위한 최소한의 널빤지의 개수를 구하는 문제이다. 웅덩이가 존재하지 않는다면 position 을 1 씩 더해주는 방식을 사용했는데 start 와 현재 위치 중 더 최대인 값을 갖게 하는 방식으로 푸는 방식이 더 효율적이다. 그리고 위치를 기반으로 널빤지의 개수를 산출할 때도 while 문을 사용하는 것보다는 `나중 위치 - 현재 위치`를 널빤지의 길이로 나누고 올림을 해주는 방식이 더 효율적이였다. 그리고 위치의 변경은 최대값으로 산출한 현재 위치에서 해당 널빤지의 길이 곱하기 갯수를 통해 풀 수 있다.

## 문제 회고

풀이는 어렵지 않았지만 불필요한 while 문 사용으로 빠른 풀이에 비해 시간이 6배나 더 소요됐다.

## 소스 코드

```jsx
// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs').readFileSync('TESTCASE/index.txt').toString().trim().split('\n');
const log = console.log;

## 208ms
const solution = (input) => {
  const [N, L] = input[0].split(' ').map(Number);
  const array = input.slice(1).map(v => v.split(' ').map(Number));
  const [START, END] = [0, 1];
  array.sort((a, b) => a[START] - b[START]);

  let position = 0, answer = 0;
  for (const [start, end] of array) {
    if (end <= position) continue;
    const maxStartPoint = Math.max(position, start);
    const count = Math.ceil((end - maxStartPoint) / L);
    answer += count;
    position = maxStartPoint + (count * L);
  }
  log(answer);
};

solution(input);

## 1564ms
const solution = (input) => {
  const [N, L] = input[0].split(' ').map(Number);
  const array = input.slice(1).map(v => v.split(' ').map(Number));
  const [START, END] = [0, 1];
  array.sort((a, b) => a[START] - b[START]);

  let position = 0, answer = 0;
  for (let i = 0; i < N; i++){
    const [start, end] = [array[i][START], array[i][END] - 1];
    while (position <= end) {
      if (position < start) position++;
      else {
        position += L;
        answer++;
      }
    }
  }
  log(answer);
};

```
