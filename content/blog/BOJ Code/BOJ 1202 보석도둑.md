---
title: '[백준 1202] 보석 도둑 (Node.js)'
date: 2022-03-15 11:53:13
category: 'BOJ Code'
draft: false
---

## 문제

[1202번: 보석 도둑](https://www.acmicpc.net/problem/1202)

## 문제접근

이전에 풀었던 BOJ 1781 컵라면문제와 유사한 유형이다. 컵라면은 우선순위 큐의 길이가 해당 deadline 과 비교해서 커지면 우선순위 큐에서 가장 작은 크기의 컵라면을 제거하는 방식으로 진행하고, 이후에 남은 컵라면을 모두 더하는 방식으로 문제를 풀었다. 하지만 이번에는 보석의 무게를 담는 가방의 조건이 다 다르기 때문에 별도로 고려해줘야할 사항들이 있다.

처음에는 가치를 기준으로 정렬을 해야한다고 생각했다. 결국 원하는 결과는 가치가 가장 높도록 보석을 담는 것이기 때문이다. 하지만 제약 조건에 가방에 대한 무게가 있고 아무리 가치가 높아도 담을 수 있는 가방무게가 존재하지 않는다면 담을 수 없다. 따라서 가방의 무게와 보석의 무게를 기반으로 정렬한다.

이 가방을 순회하면서 탐색을 실시한다. 이 때 보석의 index 를 추적하기 위한 변수를 별도로 저장해야한다. 만약 해당 가방보다 보석의 무게가 가벼운 경우에는 보석을 넣었다고 가정하고 우선순위 큐에 넣어준다. 이 때 최소 힙으로 구현했기 때문에 해당 value 에 - 를 붙여서 넣어준다. 왜냐하면 해당 가방에 더 이상 넣을 수 없을 때 우선순위 큐에서 값을 꺼내는데 이 때 최소를 나타내기 위해서는 - 가 필요하기 때문이다.

만약 가방의 무게보다 큰 보석을 만나면 while 문이 종료된다. 그 상황에서는 해당 가방에 들어갈 보석이 결정된 것이고 이 때 우리는 최대의 가치를 원하기 때문에 우선 순위 큐에서 가장 작은 값(- 를 붙였기 때문)을 꺼내게 되고 이를 answer 에 더해주게 된다.

다음 예제를 살펴보자.

```jsx
const jewerly = [
  [1, 1],
  [1, 1],
  [1, 1],
  [2, 5],
  [3, 5],
  [4, 10],
  [4, 10],
] // w, v
const bags = [2, 3, 4]
```

첫 번째 2 의 무게를 가지는 가방이 기준이 되는 경우에는 `[1, 1], [1, 1], [1, 1], [2, 5]` 까지 가방에 들어간다고 가정한다. 그리고 [3, 5] 의 보석의 순서가 돌아오면 2 의 무게의 배낭에는 5 라는 가치의 보석이 들어가게 되는 것이다. 이를 구현하기 위해 우선순위 큐를 활용한 것이다.

## 문제 회고

그리기하게 접근할 때 우선순위 큐 활용 문제가 많이 나오는 것 같다. 평소에 우선순위 큐 활용 문제는 안나온다고 생각하고 소홀했던 내 자신을 반성하게 됐다. 그리디와 DP 문제는 지금처럼 꾸준하게 풀면서 사고방식을 연습하는 과정이 필요한 것 같다! 그래도 알고리즘을 확실히 많이 푸니깐 조금씩 사고하는 능력이 향상되고 있는 것 같아서 뿌듯하다.

## 소스 코드

```jsx
// 1781 컵라면 풀이에 MinHeap 구현 사항이 있습니다.
// Heap 상속
class PriorityQueue extends Heap {
  constructor() {
    super()
  }

  enqueue = (priority, value) => this.insert(priority, value)
  dequeue = () => this.remove()
  isEmpty = () => this.heap.length <= 0
}

// BAEKJOON
// const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
// VSCODE : TEST_CASE 폴더 생성 후, 원하는 테스트 케이스를 index.txt 에 작성
const input = require('fs')
  .readFileSync('TESTCASE/index.txt')
  .toString()
  .trim()
  .split('\n')
const log = console.log

const solution = input => {
  const [N, K] = input[0].split(' ').map(Number)
  const array = input.slice(1, 1 + N).map(v => v.split(' ').map(Number))
  const bags = input.slice(1 + N).map(Number)

  const [WEIGHT, VALUE] = [0, 1]
  array.sort((a, b) => a[WEIGHT] - b[WEIGHT])
  bags.sort((a, b) => a - b)
  const priorityQueue = new PriorityQueue()

  let index = 0
  let answer = 0

  for (let i = 0; i < K; i++) {
    const bagSize = bags[i]

    while (index < N) {
      const [size, price] = array[index]

      if (size <= bagSize) {
        priorityQueue.enqueue(-price)
        index++
      } else break
    }

    if (!priorityQueue.isEmpty()) {
      const { key } = priorityQueue.dequeue()
      answer += -key
    }
  }

  log(answer)
}

solution(input)
```
