{"componentChunkName":"component---src-templates-blog-post-js","path":"/운영체제/메모리 관리 전략 (1)/","result":{"data":{"site":{"siteMetadata":{"title":"Ingong's Log","author":"ingong","siteUrl":"https://ingong.github.io","comment":{"disqusShortName":"","utterances":"ingong/ingong.github.io"},"sponsor":{"buyMeACoffeeId":"ingong"}}},"markdownRemark":{"id":"1947603f-1e6f-53ab-89b1-53d185c0823d","excerpt":"TL;DR 메모리 관리의 목적과 역사 Logical and Physical Address Address Binding MMU (Memory Management Unit) Contiguous allocation Fragmentation (외부단편화, 내부단편화) 메모리 관리의 목적 쉽게 메모리를 사용할 수 있도록 추상화를 제공 운영체제의 목적 중 하나는 컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공한다. 이러한 맥락에서 메모리 관리는 프로그래머가 쉽게 메모리를 관리할 수 있게 한다.…","html":"<h2 id=\"tldr\" style=\"position:relative;\"><a href=\"#tldr\" aria-label=\"tldr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TL;DR</h2>\n<ul>\n<li>메모리 관리의 목적과 역사</li>\n<li>Logical and Physical Address</li>\n<li>Address Binding</li>\n<li>MMU (Memory Management Unit)</li>\n<li>Contiguous allocation</li>\n<li>Fragmentation (외부단편화, 내부단편화)</li>\n</ul>\n<h2 id=\"메모리-관리의-목적\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%9D%98-%EB%AA%A9%EC%A0%81\" aria-label=\"메모리 관리의 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리의 목적</h2>\n<ol>\n<li><strong>쉽게 메모리를 사용할 수 있도록 추상화를 제공</strong></li>\n<li>운영체제의 목적 중 하나는 컴퓨터 시스템을 <strong>편리하게 사용할 수 있는 환경 제공한다.</strong></li>\n<li>이러한 맥락에서 메모리 관리는 프로그래머가 쉽게 메모리를 관리할 수 있게 한다.</li>\n</ol>\n<p><strong>2. 적은 오버헤드로 성능을 최대한 이끌어낼 수 있도록 프로세스 간 부족한 메모리 자원을 적절히 할당</strong></p>\n<ul>\n<li>만약 램이 8GB이고 프로그램이 10GB의 메모리가 필요한 상황에서 메모리 관리 기능을 통해 프로그램 수행을 가능하게 한다.</li>\n</ul>\n<p><strong>3. 메모리 보호 기능</strong></p>\n<ul>\n<li>다른 프로세스가 본인 프로세스 외의 영역을 침범하지 못하도록 한다.</li>\n</ul>\n<h2 id=\"메모리-관리의-역사\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%9D%98-%EC%97%AD%EC%82%AC\" aria-label=\"메모리 관리의 역사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리의 역사</h2>\n<ol>\n<li><strong>Batch Programming</strong></li>\n<li>Batch 프로그래밍 시절에는 메모리 관리가 필요하지 않았다.</li>\n<li>프로세스 하나를 메모리에 로드하고, 해당 프로세스가 다 수행되고 나면 다른 프로세스를 올리는 방식이 Batch System이기 때문이다.</li>\n<li><strong>Multi-Programming</strong></li>\n<li>한 번에 여러 프로세스가 메모리에 올라가게 되면서 메모리 관리가 중요해졌다.</li>\n<li>Multi-Programming이 등장하면서 메모리 보호, Fast Translation이 필요해졌다.</li>\n<li>이번 장에서 다룰 내용도 1960년대, 70년대 초반에 정립된 내용이다.</li>\n</ol>\n<h2 id=\"logical-and-physical-address\" style=\"position:relative;\"><a href=\"#logical-and-physical-address\" aria-label=\"logical and physical address permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Logical and Physical Address</h2>\n<ul>\n<li>가상 메모리 주소 (Logical Address = Virtual Address)</li>\n</ul>\n<p>각 프로세스마다 독립적으로 가지는 주소 공간이다. 주소가 0부터 시작한다. CPU가 바라보는 주소는 Logical Address이다.</p>\n<ul>\n<li>물리 메모리 주소 (Physical Address)</li>\n</ul>\n<p>물리 메모리가 실제 올라가는 위치이다.</p>\n<ul>\n<li>주소 바인딩</li>\n</ul>\n<p>각 프로세스마다 논리적 주소는 0번부터 시작하기 때문에 물리 메모리에 올라가기 위해서는 가상 메모리 주소가 물리 메모리 주소로 바뀌는 과정이 필요하다. 이 과정을 <strong>주소 바인딩</strong>이라고 한다. 주소 바인딩이 일어나는 시점에 따라 Compile Time Binding, Load Time Binding, Execution Time Binding으로 나뉜다.</p>\n<h2 id=\"address-binding\" style=\"position:relative;\"><a href=\"#address-binding\" aria-label=\"address binding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Address Binding</h2>\n<ol>\n<li><strong>Compile Time Binding</strong></li>\n<li>Physical Address가 컴파일 시 결정되며, 시작 위치 변경 시 다시 컴파일 과정을 거쳐야한다.</li>\n<li>과거 시스템 내에 하나의 프로그램이 실행될 때 사용되었으며 최근의 시스템에서는 사용하지 않는다.</li>\n<li><strong>Load Time Binding</strong></li>\n<li>소스 코드가 컴파일되어 Logical Address만 결정되고 메모리에 올라갈 때 Physical Address가 결정되는 방식이다.</li>\n<li>Loader의 책임하에 Physical Address를 부여하여 컴파일러가 재배치 가능한 코드를 생성한 경우에 가능하다.</li>\n<li><strong>Execution Time Binding</strong></li>\n<li>Load time binding처럼 physical address가 프로그램 실행시에 결정된다.</li>\n<li>차이점은 수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있다는 점이다.</li>\n<li>CPU가 주소를 참조할 때마다 binding을 점검(address mapping table)하며 하드웨어적인 지원이 필요(base and limit register, MMU)</li>\n</ol>\n<h2 id=\"mmu-memory-management-unit\" style=\"position:relative;\"><a href=\"#mmu-memory-management-unit\" aria-label=\"mmu memory management unit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MMU (Memory Management Unit)</h2>\n<ul>\n<li>CPU 코어안에 탑재되어 CPU가 메모리에 접근하는 것을 관리하는 하드웨어 부품이다.</li>\n<li><strong>가상 메모리 주소를 실제 메모리 주소로 변환</strong>한다.</li>\n<li>이외에도 메모리 보호, 캐시 관리 등의 역할을 담당한다.</li>\n</ul>\n<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1104px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 28.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxklEQVQY022QWQ4EIQhEvf89e7P3tvetJo+MEz+GBEGgilKnrzVNo2EY4lX3fauqKs3zbPfnefS+r9XbtlXXdXZPHXPXdek4DuV5bgTkgNZ1VZZl8t5rWRbt+65t26x/nqfAUZ+m6RepuXEcDYyhBtK+720IIw8hqCgKewEvgZh+XdfWp0eNRUYICSA2AEIV5KhBGQtxQNSZw8nBQ8ycKYQVj39AEfLU0v/7Z2nPcaAIlUS2xZxYlqXlRJ5LDWeOPyZHZST+ALJu0CblF/8SAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"MemoryManageMent1\" title=\"MemoryManageMent1\" src=\"/static/3a44644bbe651776a608bb9f8794b158/7388e/MemoryManageMent1.png\" srcset=\"/static/3a44644bbe651776a608bb9f8794b158/5a46d/MemoryManageMent1.png 300w,\n/static/3a44644bbe651776a608bb9f8794b158/0a47e/MemoryManageMent1.png 600w,\n/static/3a44644bbe651776a608bb9f8794b158/7388e/MemoryManageMent1.png 1104w\" sizes=\"(max-width: 1104px) 100vw, 1104px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</div>\n<ul>\n<li>기준점의 위치가 다르더라도 offset이 같기 때문에 더하기를 통해 물리적 주소도 논리적 주소처럼 연속적으로 배치된다.</li>\n<li>CPU에 의해 수행되는 프로세스는 주소 값을 생성하며, MMU는 이 모든 주소 값에 대해 Base Register(Relocation Register)의 값을 더한다.</li>\n<li>가상 메모리상의 Logical Address가 346이라고 할 때, relocation register값을 더한 값이 실제 물리 메모리 주소가 된다.</li>\n<li>Relocation register을 더하기 전에 Logical Address가 limit register보다 더 큰지 검사한다.</li>\n<li>만약 더 크다면 Memory Protection Fault를 발생시킨다.</li>\n</ul>\n<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 982px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB4ElEQVQ4y41Uy3KjMBD0///JXrf24LiyifNwMAJJiKckBNiVD+mdEYuxs9lUDmIoaabpnh6xGacBH9cwhi/fnXdoGgfvR7Sth7X2cr75HxjHMPSYTmOMcX8cvgfIL9drLrIQWYrH/QPyXKDtmu8x/EzS6TxRsoPWCnd3O4oarW0jWz77B9BZTOdxZciSFnnMpKwMfO9QVRWen19hjKGiDqY0qOoSfegjEAN2XY+mbSMBxtpMp4EYFEiSDFIpPD3tsd1uobREcnyjsxKFKZCR7N1uh/vf9xAixTFJoaSCSAVykcOoYgbkhy4KSshQUKzrKoIxUy5MDgIFfZBZS5nTmaI8HfOGKVCsiW2D8/tplswyF0c5gXvEe33wSN8Efv74hdfHA6zv1v5SO3SuiJVBWZQku11N6f7qD9SXQCBt06wuH1O87F+QkryLy9QiazsypY41DMYML4CS9LMElsS9qsmIxXUfXBwdZrQUMHsGrOuGVAQi0MWWMNsIyNL4a9wLjpz8cYSux4pNdM4RCa4h501NLDsMQ1gAiTbJ1rlGZaoof+nrZ2sGtJCphJYaUkh4t9Zs+t5HQ9glXtzDa5bzlbu9RdHEMM8ux+v9DSerjObpkMbF89SQ/FvA2zv+1Q/lD/cJ2l55N3WOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"MemoryManageMent2\" title=\"MemoryManageMent2\" src=\"/static/8bb43b0b80638c5e5d77d26adf86a593/84a90/MemoryManageMent2.png\" srcset=\"/static/8bb43b0b80638c5e5d77d26adf86a593/5a46d/MemoryManageMent2.png 300w,\n/static/8bb43b0b80638c5e5d77d26adf86a593/0a47e/MemoryManageMent2.png 600w,\n/static/8bb43b0b80638c5e5d77d26adf86a593/84a90/MemoryManageMent2.png 982w\" sizes=\"(max-width: 982px) 100vw, 982px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</div>\n<h3 id=\"memory-protection-fault\" style=\"position:relative;\"><a href=\"#memory-protection-fault\" aria-label=\"memory protection fault permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory Protection Fault</h3>\n<ul>\n<li>CPU가 자기 자신한테 인터럽트를 거는 것을 Exception 또는 Trap이라고 부른다.</li>\n<li>Fault 명령어를 사용해 CPU는 운영체제에게 본인은 수행할 수 없는 명령어라고 이야기하면서 운영체제에게 도움을 요청한다.</li>\n</ul>\n<h2 id=\"contiguous-allocation\" style=\"position:relative;\"><a href=\"#contiguous-allocation\" aria-label=\"contiguous allocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contiguous allocation</h2>\n<p>: 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 방식이다.</p>\n<ul>\n<li><strong>고정 분할 방식</strong></li>\n</ul>\n<p>물리적 메모리를 몇개의 영구적 분할(Partition)로 나누는데, 이 때 분할 크기가 모두 동일한 방식과 서로 다른 방식이 존재한다. 분할당 하나의 프로그램이 적재된다.</p>\n<p>해당 방식은 융통성이 없다는 단점을 갖는다. 동시에 메모리에 로드되는 프로그램 수가 고정되며, 내부 단편화와 외부 단편화가 발생한다.</p>\n<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 478px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 105.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC40lEQVQ4y31V23bTMBD0//8JD8BDH7j0HGhpEmLHjm+6y3YKPzLMrpPQQtuHPdKRtaPZ2ZFcLKcZU05IbYs09JjGAalpkGU8HpGNgeyZl0lD5m9Fsfw6Ie9LhA83CJ9vkT59gX/3HvHTV/iPN4g/NljOYAq4zGu8BqibUsSJLBcJmU8yj1imjGXOV4ZPmb4WxfJI5F8Llsd/gmuzAMjJT8CUyeML7M5rRfQBwXmkGBlBx+g9gnWYZwGYnuk3kXWwHjHEc84a3q4YhR+dTo67I7p9i3pTIwigC2xWft4Qsojn9aEZ0O5atD9b9IceOSUE41EEyw3UybRGTzadURaJDF4EZEXC3BsHy71ucJx7XZPDCnMcEYKHNRZd3cGOFp4Mx3ZcAZ/odaKuwtxxT3AEctxrOfdO8+1gWTJPkCTbW1TfDjCNQSZQtGtp0zQhsfMSmd2PnsyF/XaHWFaIYrm7B6R+4CHU0B4tEje51qHfdgoYTIA9Gsws3XVkvu9UCtFLyhq6gVpXaHYV6ocKbVlj4KVQhq5buynA5W2pyXJAGL0ylBJHytKVnVYhGg52RFU2aHi76gObaQaYbFWuwrYWOSQFkfESwkwARfSxHtHvyYCNE4aRFWQmJzYmcow9+yDNGaXL/HhSY894/L3oXOLSTbFCt+uwudmi/lHTEew4/Zq3W975A1K5R76/x2R5GIkUgnoikKeRy28VxsOgFlHxyVDmYiPx2cUadhRXUIrewTB0HLxWwy57tYT4TkoSxsrM/jX21TZnY7cmYrMb8P22wcOmx91dg7Kjh6Vk6abqwshx1TKx/bL+2k1xTPQ2qE10tFHXHJleNbyUJuNFw7duirCV8ToXmQj+V0Oi77+W6Ktegd8CvBzc3B9R3VXa3VUmliz3UBjp/eVtkPGa+Aag6s5GSY5+P+uuDDVpXl/j9ZlaT3v1tUn52eutcskl0NfGBU3+L8zlPXz+P9HEF/bL6yNO+QMUH8iINUZ8CAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"MemoryManageMent3\" title=\"MemoryManageMent3\" src=\"/static/b9b0b234483ba1b220bf689ed05fcbec/50978/MemoryManageMent3.png\" srcset=\"/static/b9b0b234483ba1b220bf689ed05fcbec/5a46d/MemoryManageMent3.png 300w,\n/static/b9b0b234483ba1b220bf689ed05fcbec/50978/MemoryManageMent3.png 478w\" sizes=\"(max-width: 478px) 100vw, 478px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</div>\n<ul>\n<li><strong>가변 분할 방식</strong></li>\n</ul>\n<p>프로그램의 크기를 고려하여 Partition을 할당한다. 분할의 키기와 개수가 동적으로 변한다. 사용후 반납된 메모리를 관리하는 등의 필요가 발생하기 때문에 기술적 관리 기법이 필요하다. 외부 단편화가 발생한다.</p>\n<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 494px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 96%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAACrElEQVQ4y3VU6XqjMAzM+z/RXu3XtGkuMOAL22BDdl9kVhKhaXr80OdTY2k08qb0HvHnHwyHI8LrHmH7jLg/INI4KIUyF5Qpi03XOY/f2SY7i/DrN4HsEV92cA+PCLsdwtMWQ6Mw/50wX8od2PrAV7bJJWMYC1lGGkbkeaL5iHFix4LoA2IfUMqHCC8foruuN6lPaHct2n2L+rmCeqlxfjzD1Bq66tAd6IxsHIY35zEPSCliHAeZr+thSNjMF4ooJTFvPFxrYRtLUUXZYyBOe5pvEXLEKUS6Z2CUgVUWKUYE32PDlyIdckoCRoemMgLGe0NM9/zJXkTOI2Wg5XFXO0xED4NuOHd+UbgiC64XW+fvAVeTc8pguUv37LL22l0BQ5CNbt9BHzTa11aMLzJPS8oL8WvKkYDalxb2bKG2DczJoCfK7iJ0ysPWlHZlZQyW9loH1zhZ+86JU+89ulZDHRVURXZW6CP5GvsOkF7sXrmqnUSnnpQ485rNEq+nhxMpoYanZmi6BtW5Qq1qVFUNGw200SsgSSBRaqumiOCZ9Mh7nLbwRHy1x1aiTHR/KmUR/czCn8SH7wggSyAXEjVVkKuXx2XOuuI506FPGvsfB1EC77GcmIpe94tsCINNZCOABGSORooixTnrN31yJBe2f7MUheXBoE45ROKZZcZZLoBXDlMgEcdBZMLG80SRMeBn2QRkatNCaZecl5GsN/0NcAhLVzBvbOzwBni5/xiYAr7PAFzMXvtFt+Ydh9L8l1uTc5qswU+AzC31LT/I1FhqPf4HXGNvKa8cTh/+Po74qwi5mvyYFDIvI38QvfU32XwLGG+AZV7OvHdQncJxd8TpfML+cIBJVFB71SE7cbWSWwTOJnNuveu3tQKK3qhVdUctWrXoGhoVpUyPOOfwH89UOZhKNb7+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"MemoryManageMent4\" title=\"MemoryManageMent4\" src=\"/static/61e03696e5e5db10f4136f8d685a8d3c/d72d4/MemoryManageMent4.png\" srcset=\"/static/61e03696e5e5db10f4136f8d685a8d3c/5a46d/MemoryManageMent4.png 300w,\n/static/61e03696e5e5db10f4136f8d685a8d3c/d72d4/MemoryManageMent4.png 494w\" sizes=\"(max-width: 494px) 100vw, 494px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</div>\n<ul>\n<li><strong>Hole</strong></li>\n</ul>\n<p>물리 메모리 상의 가용 메모리 공간이다. 다양한 크기의 Hole들이 메모리의 여러 공간에 걸쳐 흩어져있다. 프로세스가 메모리에 적재되어야하는 순간에 수용가능한 Hole에 프로세스를 할당한다. 운영체제는 할당 공간이나 가용 공간의 정보를 유지해야한다.</p>\n<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 786px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 33.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSElEQVQozz2SWW7DMAxEff8TtSi6t/EuWbsl20mai0yHKpoPAoY4fBySbuxoEIzHmhLOlwOlZCQfYYYFa0zI64rjvKPkDKcs3Gz5vWLbNux7YT5h6RZEFyqjsYOpohTiHeiVg7wnGypIgAIP2sMz1pAI22pEakQfFl81jaFDxwcBXm9nZAKG9xHdywDVanZdcfk518L2oUX72NZiaSKhT4pvHaaPuTKaYALtRqQYUVa6sx6ao1mOoDWdLg6ZUGk6fc+YTjMM8+JSHOmTRv/UQ33OdVVNJDARKEkBBjq5AwlxdFNShhE4CxxD8olAiblVbKIwdwrOOI7cGdjRVpfX26WO3L+NaJ/7KvwfWcDd81BXsUwWx7FjP7YK7F9HjF8TgZ5HYdKxuziUo2xb4eLd36HoZiuFuzruY8sBMq8pMInIFYlW/hS5/i9JyOZWJUcx1QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"MemoryManageMent5\" title=\"MemoryManageMent5\" src=\"/static/6a60012575adb2323a2f8bfe5587e87a/321ea/MemoryManageMent5.png\" srcset=\"/static/6a60012575adb2323a2f8bfe5587e87a/5a46d/MemoryManageMent5.png 300w,\n/static/6a60012575adb2323a2f8bfe5587e87a/0a47e/MemoryManageMent5.png 600w,\n/static/6a60012575adb2323a2f8bfe5587e87a/321ea/MemoryManageMent5.png 786w\" sizes=\"(max-width: 786px) 100vw, 786px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</div>\n<ul>\n<li><strong>프로세스를 어떤 Hole에 할당해야할까?</strong></li>\n</ul>\n<p>Dynamic Storage Allocation Problem으로 Size가 N인 요청을 만족하는 가장 적절한 Hole을 찾는 문제이다.</p>\n<ol>\n<li>First-fit : size가 n 이상인 것 중 최초로 찾아지는 Hole에 할당</li>\n<li>Best-fit : size가 n 이상인 가장 작은 Hole에 할당. 모든 Hole List를 탐색해야함.</li>\n<li>Wort-fit : 가장 큰 Hole에 할당. 모든 Hole List를 탐색해야함.</li>\n<li><strong>Compaction</strong></li>\n</ol>\n<p>외부 단편화(필요한 작업 메모리보다 많은 메모리 공간을 갖고 있음에도 프로세스를 받아 들이지 못하는 상황)를 해결하는 하나의 방법이다. 사용 중인 메모리 영역을 한 쪽에 몰아놓고 큰 가용 공간을 확보한다. 매우 비용이 많이 드는 방법이고 복잡한 방법이다. 이는 메모리 바인딩이 Run Time Binding이 가능한 경우에만 수행이 가능하다.</p>\n<h2 id=\"fragmentation\" style=\"position:relative;\"><a href=\"#fragmentation\" aria-label=\"fragmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fragmentation</h2>\n<p>: RAM에서 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태이다.</p>\n<ul>\n<li><strong>내부 단편화</strong></li>\n</ul>\n<p>: 메모리를 할당할 때 <strong>프로세스가 필요한 양보다 더 큰 메모리가 할당되어서</strong> 프로세스에서 사용하는 메모리 공간이 낭비 되는 상황이다.</p>\n<ul>\n<li><strong>외부 단편화</strong></li>\n</ul>\n<p>: 메모리가 할당되고 해제되는 작업이 반복되면 중간중간에 생긴 사용하지 않는 메모리가 많이 존재하게 된다. 이러한 이유로 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황이 발생한다. 이를 외부 단편화라고 한다.</p>\n<p>각각의 단편화를 해결하기 위해서는 세그멘테이션 기법과 페이징 기법이 존재한다. 이에 대해서는 다음 포스팅에서 다루려 한다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>reference</h2>\n<ul>\n<li><a href=\"https://jhnyang.tistory.com/notice/31\">jhnyang.tistory 글의 Chapter 8 메모리 관리</a></li>\n<li><a href=\"https://www.inflearn.com/course/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EB%A3%A1%EC%B1%85-%EC%A0%84%EA%B3%B5%EA%B0%95%EC%9D%98/lecture/63005?tab=curriculum\">인프런 운영체제 공룡책 강의</a></li>\n<li><a href=\"http://www.kocw.net/home/search/kemView.do?kemId=1046323\">반효경 교수님 운영체제 강의</a></li>\n<li><a href=\"https://kosaf04pyh.tistory.com/245?category=1032510\">반효경 교수님 운영체제 강의 정리 블로그 글</a></li>\n</ul>","frontmatter":{"title":"메모리 관리 전략 (1)","date":"May 01, 2022"}}},"pageContext":{"slug":"/운영체제/메모리 관리 전략 (1)/","previous":{"fields":{"slug":"/PS/PG Level3 카카오 보석쇼핑/"},"frontmatter":{"title":"[PG Level3] 카카오 보석쇼핑 (Node.js)"}},"next":{"fields":{"slug":"/운영체제/메모리 관리 전략 (2)/"},"frontmatter":{"title":"메모리 관리 전략 (2)"}}}},"staticQueryHashes":["2486386679","3128451518"]}