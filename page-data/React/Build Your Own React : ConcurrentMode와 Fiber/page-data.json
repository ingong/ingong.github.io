{"componentChunkName":"component---src-templates-blog-post-js","path":"/React/Build Your Own React : ConcurrentMode와 Fiber/","result":{"data":{"site":{"siteMetadata":{"title":"Ingong's Log","author":"ingong","siteUrl":"https://ingong.github.io","comment":{"disqusShortName":"","utterances":"ingong/ingong.github.io"},"sponsor":{"buyMeACoffeeId":"ingong"}}},"markdownRemark":{"id":"95458cd2-fc9b-549c-b321-aa05ea8c9988","excerpt":"이 포스팅은 Build your own React 를 읽고 학습한 내용을 정리한 글 입니다. concepts 브라우저(렌더러 프로세스)의 메인 스레드는 변경 사항을 사용자의 화면에 적용하는 역할을 수행한다. 변경 사항은 CSS, 사용자 입력, 자바스크립트 등에 의해 유발될 수 있다. 현대의 디바이스에서는 최고의 사용자 경험을 제공하기 위해 초당 60프레임(FPS)에 렌더링될 것을 기대한다. 이를 위해서는 각 렌더링마다 코드가 실행되는데 16.67밀리초 미만이 걸려야한다. 만약 해당 frame…","html":"<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 787px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 19.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+klEQVQY0x3MyU4CQRRAUf7YjUYSB3AgEhQxGtCNSwkgMa4JQtxq60cAaiJCQ9tDdVVXX5+1OHnD4hZsuiZTC8emC7RShEHG79oQRyI0bo/kF6YBq3gpfKI0dPP/9kWQrLG5pbDyivgvW/jeHoG3wXR8TPvyk15rRvtixp3oNCd0G3NanT7V0Ta1QYmTwQ7VwS5nwzKnwxK14T4/4bcE38v4r0WWXongbZPJc51u88sFe9cf3P+7mdK/mnP78CjBokQOaIwrEirTGFWoPx1yPjpiEc4p2ExhTeTkwhiLSnKRYbRFp3LHllSJLCHRsaMz7WasI0eZhDzP+QNlPBWlg3hIEAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Concurrent1\" title=\"Concurrent1\" src=\"/static/a74066106a6e92d3d6aaf71a38c07a41/e619b/Concurrent1.png\" srcset=\"/static/a74066106a6e92d3d6aaf71a38c07a41/5a46d/Concurrent1.png 300w,\n/static/a74066106a6e92d3d6aaf71a38c07a41/0a47e/Concurrent1.png 600w,\n/static/a74066106a6e92d3d6aaf71a38c07a41/e619b/Concurrent1.png 787w\" sizes=\"(max-width: 787px) 100vw, 787px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</div>\n<blockquote>\n<p>이 포스팅은 <a href=\"https://pomb.us/build-your-own-react/\">Build your own React</a> 를 읽고 학습한 내용을 정리한 글 입니다.</p>\n</blockquote>\n<h2 id=\"concepts\" style=\"position:relative;\"><a href=\"#concepts\" aria-label=\"concepts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>concepts</h2>\n<p>브라우저(렌더러 프로세스)의 메인 스레드는 변경 사항을 사용자의 화면에 적용하는 역할을 수행한다. 변경 사항은 CSS, 사용자 입력, 자바스크립트 등에 의해 유발될 수 있다.</p>\n<p>현대의 디바이스에서는 최고의 사용자 경험을 제공하기 위해 초당 60프레임(FPS)에 렌더링될 것을 기대한다. 이를 위해서는 각 렌더링마다 코드가 실행되는데 16.67밀리초 미만이 걸려야한다. 만약 해당 frame에 렌더링하지 못한다면 page jank가 발생하고 사용자가 버벅거림을 느끼게 된다.</p>\n<p>리액트는 JavaScript기반이며 당연히 싱글스레드기반이기 때문에 동일한 문제를 겪는다. 리액트는 이를 Concurrent Mode를 통해 해결하려고 한다. Concurrent란 동시성을 의미하며, 동시성이란 프로그램을 독립적으로 실행할 수 있는 여러 조각으로 나누어 구조화하는 방식이다.</p>\n<p>현재까지의 리액트는 재조정 과정을 한번 시작하면 이 과정이 끝나기 전까지는 이를 멈출 수 없다. 현대의 디바이스가 기대하는 수준을 넘어선 시간이 소요된다면 사용자는 좋지 못한 사용자 경험을 할 것이다. 예를 들면 사용자 입력에 따른 DOM요소 변경이 잦아 사용자의 키보드 입력이 즉시 UI에 나타나지 않을 수 있다.</p>\n<h2 id=\"설명적-렌더링\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EB%AA%85%EC%A0%81-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"설명적 렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설명적 렌더링</h2>\n<p>리액트는 동시성 모드를 통해 렌더링 과정을 더 작은 작업들로 나누고, 스케줄러를 활용해 중요도에 기반한 각각의 작업에 우선순위를 부여한다. 이를 통해 리액트는 다음과 같은 작업을 할 수 있다.</p>\n<ul>\n<li>메인 스레드를 블록하지 않는다</li>\n<li>동시에 여러 작업들을 처리하고, 우선 순위에 따라 각 작업들 간에 전환할 수 있다</li>\n<li>최종 결과로 확정하지 않고도 부분적으로 트리를 렌더링할 수 있다</li>\n</ul>\n<p>렌더링 과정이 더 이상 프로세스를 블록하지 않으므로 이는 설명적(imperative)이며, 이제 사용자가 키를 누르는 등의 더 높은 중요도를 가지는 작업이 실행되었을 때 렌더링이 나중으로 미뤄질 수 있다. 즉, 사용자 입력에 대한 UI 반영이 더 높은 우선순위를 갖는 작업이 되고 더 빠르게 반영된다.</p>\n<p>리액트는 <strong><code class=\"language-text\">requestIdleCallback()</code></strong> 함수를 사용하였다가 <strong><code class=\"language-text\">requestAnimationFrame()</code></strong>을 활용하는 방식으로 <a href=\"https://github.com/facebook/react/issues/11171\">변경</a>하였고, 현재 <a href=\"https://github.com/facebook/react/tree/main/packages/scheduler\">scheduler 패키지</a>를 사용한다. 이번 포스팅에서는 작업을 작은 단위로 쪼개는 개념은 동일하기 때문에 <strong><code class=\"language-text\">requestIdleCallback()</code></strong> 함수를 활용한다.</p>\n<h2 id=\"step-iii-concurrent-mode\" style=\"position:relative;\"><a href=\"#step-iii-concurrent-mode\" aria-label=\"step iii concurrent mode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step III: Concurrent Mode</h2>\n<p>먼저 Element를 렌더링하는 작업을 작은 단위로 나누자. 그래서 각 작업이 끝난 다음 브라우저의 상태를 확인해보고, 더 중요한 작업이 필요하다면 렌더링 작업을 잠시 멈추고 해당 작업을 수행하도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 다음 렌더링 작업</span>\n<span class=\"token keyword\">let</span> nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">deadline</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> shouldYield <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextUnitOfWork <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>shouldYield<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 다음 렌더링 작업을 수행하고, 다시 다음 렌더링 작업을 지정한다.</span>\n    nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>nextUnitOfWork<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 주어진 idle 시간이 1ms 보다 적다면 loop를 빠져나오고 다음 frame을 기다린다</span>\n    shouldYield <span class=\"token operator\">=</span> deadline<span class=\"token punctuation\">.</span><span class=\"token function\">timeRemaining</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span>workLoop<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 브라우저가 idle 상태일 때 workLoop를 호출하도록 한다</span>\n<span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span>workLoop<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextUnitOfWork</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// TODO: add dom node</span>\n  <span class=\"token comment\">// TODO: create new fibers</span>\n  <span class=\"token comment\">// TODO: return next unit of work</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><code class=\"language-text\">nextUnitOfWork</code></strong> 에는 다음 렌더링할 작업을 저장하고, <strong><code class=\"language-text\">performUnitOfWork()</code></strong> 함수에 전달하여 렌더링한 뒤 다음 렌더링 작업을 선정하여 반환하도록 하자.</p>\n<p><strong><code class=\"language-text\">requestIdleCallback()</code></strong> 함수는 매 frame마다 main thread가 idle한 때에 callback 함수를 실행할 수 있도록 한다. argument로 받은 함수에 <strong><code class=\"language-text\">deadline</code></strong> 파라미터를 전달한다. 이 파라미터의 메서드를 통해 현재 프레임에서 남은 idle 시간이 얼마인지 계산할 수 있는데, 여기서는 1ms 보다 적으면 더 이상 렌더링 작업을 하지 않고 다음 frame에서 진행하도록 루프를 빠져나오게 한다.</p>\n<p><strong><code class=\"language-text\">requestIdleCallback</code></strong>에 대한 내용이 잘 이해가 되지 않아서 공부해봤다. MDN 문서에 따르면 <strong><code class=\"language-text\">window.requestIdleCallback()</code></strong> 은 브라우저의 idle 상태에 호출될 함수를 대기열에 넣는 메서드이다. 대기 시간이 중요한 이벤트에 영향을 미치지 않고 메인 이벤트 루프에서 백그라운드 및 우선 순위가 낮은 작업을 수행할 수 있게 해준다. 이 메서드의 콜백 함수의 경우 <strong><code class=\"language-text\">deadline</code></strong> 객체를 인자로 전달받는데, 이를 통해 타임아웃 기간이 만료되어 callback이 실행되었는지 여부를 알 수 있다.</p>\n<h2 id=\"step-iv-fibers\" style=\"position:relative;\"><a href=\"#step-iv-fibers\" aria-label=\"step iv fibers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step IV: Fibers</h2>\n<p>다음 단계는 Fiber이다. Fiber는 실제 렌더링 작업을 나눈 작업 단위를 표현하는 자료구조이다. Fiber의 주요 목표는 React로 하여금 스케줄링에 있어 강점을 갖도록 하는 것이다. Fiber는 아래 항목들을 수행할 수 있어야한다.</p>\n<ul>\n<li>작업을 중단하고 나중에 다시 돌아올 수 있어야 한다.</li>\n<li>다른 종류의 작업에 우선순위를 부여할 수 있어야 한다.</li>\n<li>이전에 완료된 작업을 재사용할 수 있어야 한다.</li>\n<li>더 이상 필요 없어지면 작업을 중단할 수 있어야 한다.</li>\n</ul>\n<p>즉, Fiber를 통해 언제든지 렌더링 작업을 중지했다가 다시 작업할 수 있도록 하는 것이다. 즉, 렌더링 작업이 다른 우선순위가 높은 작업에 의해 뒤로 밀려나더라도 브라우저가 <strong>다음 렌더링 작업을 쉽게 찾을 수 있도록 하는 것</strong>\n이다.</p>\n<p>하나의 element에 대해 하나의 fiber가 대응되고, 이 fiber가 바로 위에서 정의한 <strong><code class=\"language-text\">nextUnitOfWork</code></strong>\n가 된다. JSX를 render할 때 제일 먼저 root element에 대한 fiber를 생성하고, <strong><code class=\"language-text\">nextUnitOfWork</code></strong>\n로 지정한다. 그런 다음 <strong><code class=\"language-text\">performUnitOfWork()</code></strong> 함수를 호출하여 다음 작업들을 처리해나간다. <strong><code class=\"language-text\">performUnitOfWork()</code></strong>함수는 다음 순서로 동작한다.</p>\n<ol>\n<li>주어진 element에 대한 DOM을 생성하고 DOM tree에 붙인다.</li>\n<li>주어진 element의 children에 대해 fiber를 생성한다.</li>\n<li>새롭게 <strong><code class=\"language-text\">nextUnitOfWork</code></strong>를 지정한다.</li>\n</ol>\n<p>이해를 돕기 위해 다음과 같은 DOM tree가 있다고 생각해보자.</p>\n<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 333px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 93.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAACs0lEQVQ4y3VU23baMBDMb6TBRrYsS/huLjbmEkiBEBJyaU96+tCe/v9fTFcydiCQhzmWLHs0u7O7V8z10cBmHnwVoRhPUVYzZP0RrC43Z12Hzg+46fq4tut1fSZajqtjQqvrIYhSrO932GyfMCwmLaHnCQS+gCLMc4H1sN5bTJyQtoTNC/10mIs0DcBFvdfwPB+h8hEQFgOJh0ohCdVB5SWFhx/1OlUeJlUGFQSUhvq9kAph1EOSBHh+LLDbjrC7H8Dh4jTk7hFR8xzHHIM8pHz2WkLXD+GFOUSUodg+Y3j/gmS+gSMCOvc+CLlQdItsyYwxFCoX0qwb9Y7XgysjuCpGUK0QjO8QzbfgKkGXHRE+7V+MqzeWYw6iosDr+y+8//qN0WKBrivaPOpzDctiBrbtnEV39fL6A8NRZQj1C8ejXCU5IoIng9oQIU/yxFx5wIWyWW8eKPnJSXiSO6jGCVSvzuF83odUypTVZ4Izwtvlyqhp6k1jEAqURWJc1iQO91GUKeThAsb9rwn//P2H2e0drm9YbQ4pzSVDr+e3JWETqUvrmMpG7zuWi47twiKc5fD17SfitG8UmnypEOX0FvmggB/VDnIZgvdScjglk3wMK2rNMbXmqDSmsWOFk9nC9K9tlHD00hy71zdUsyWScmzUMZlA5mPIfgXmSaye9tg97jFZrcz+JORGWSudFNlUEgG1lXNoqSwLzWVdxo0aXREanUshX2q9WAlMJ1lrSkmGZHncDoLP+HLaNAeTVGA0jNvW69hkVD9GmkW1y7peubxYQicKmw88xsCYe5IG7ageYWbM0fpbh7rF5u0/5yE3B1Rj0/UGy+0DRJgYU/RQUIMJ1HBmcpmSWdv9M5Ki/GiISyGb2+mDcjpHNV+0DuqJoocCJ2gCSUN4tvwOP4hJ/WnI/wGkqiuXd693IwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Concurrent2\" title=\"Concurrent2\" src=\"/static/366eaf3c5ebe93c1317bc63f2c56de45/24c7e/Concurrent2.png\" srcset=\"/static/366eaf3c5ebe93c1317bc63f2c56de45/5a46d/Concurrent2.png 300w,\n/static/366eaf3c5ebe93c1317bc63f2c56de45/24c7e/Concurrent2.png 333w\" sizes=\"(max-width: 333px) 100vw, 333px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</div>\n<p>위 트리에서 <strong><code class=\"language-text\">&lt;div></code></strong> fiber를 <strong><code class=\"language-text\">performUnitOfWork()</code></strong> 로 전달하면 해당 element에 맞는 DOM 노드를 생성하고 root에 붙인다. 그런 다음 children인 <strong><code class=\"language-text\">&lt;h1></code></strong>, <strong><code class=\"language-text\">&lt;h2></code></strong>element에 대응되는 fiber를 생성한다. 마지막으로 <strong><code class=\"language-text\">&lt;h1></code></strong> fiber를 <strong><code class=\"language-text\">nextUnitOfWork</code></strong>로 선정하고 종료한다. <strong><code class=\"language-text\">nextUnitOfWork</code></strong>를 선정하는 과정은 먼저 child가 있는지, sibling이 있는지 확인하고 없다면 parent로 올라가 root에 도달할 때 까지 이를 반복한다. 즉 위 트리에서 <strong><code class=\"language-text\">nextUnitOfWork</code></strong>로 선정되는 순서는 <strong><code class=\"language-text\">&lt;div></code></strong> -> <strong><code class=\"language-text\">&lt;h1></code></strong> -> <strong><code class=\"language-text\">&lt;p></code></strong> -> <strong><code class=\"language-text\">&lt;a></code></strong> -> <strong><code class=\"language-text\">&lt;h2></code></strong>가 된다.</p>\n<p>위 과정을 코드로 옮겨보자. 우선 우리가 만든 <strong><code class=\"language-text\">render</code></strong> 함수에서 dom을 생성하는 부분만 함수로 추출하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// render 함수 안에서 DOM 노드를 생성하는 로직만 분리한다</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createDom</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> dom <span class=\"token operator\">=</span>\n    fiber<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> <span class=\"token string\">'TEXT_ELEMENT'</span>\n      <span class=\"token operator\">?</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createTextNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n      <span class=\"token operator\">:</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isProperty</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">key</span> <span class=\"token operator\">=></span> key <span class=\"token operator\">!==</span> <span class=\"token string\">'children'</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>isProperty<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      dom<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> dom\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고 <strong><code class=\"language-text\">render</code></strong> 함수는 root element에 대한 fiber를 생성하고 <strong><code class=\"language-text\">nextUnitOfWork</code></strong>로 지정한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">element<span class=\"token punctuation\">,</span> container</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// element를 next unit of work로 선정한다.</span>\n  nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">dom</span><span class=\"token operator\">:</span> container<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">children</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>element<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다음으로 <strong><code class=\"language-text\">performUnitOfWork()</code></strong> 함수를 단계별로 작성하자. 먼저 fiber에 대한 DOM을 생성하고 <strong><code class=\"language-text\">dom</code></strong> 프로퍼티에 저장한다. 현재 fiber의 parent가 있다면 <strong><code class=\"language-text\">.appendChild()</code></strong>하여 DOM tree에 붙인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// add dom node</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>fiber<span class=\"token punctuation\">.</span>dom<span class=\"token punctuation\">)</span> fiber<span class=\"token punctuation\">.</span>dom <span class=\"token operator\">=</span> <span class=\"token function\">createDom</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">)</span> fiber<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>dom<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>dom<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// TODO: create new fibers</span>\n  <span class=\"token comment\">// TODO: return next unit of work</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다음으로 현재 fiber의 children을 순회하면서 각 child element에 대한 fiber를 생성한다. Fiber tree를 만들기 위해 각 fiber의 child, sibling 필드에 이를 저장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...add dom node(생략)</span>\n  <span class=\"token comment\">// create new fibers</span>\n  <span class=\"token keyword\">const</span> elements <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children\n  <span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">let</span> prevSibling <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">const</span> newFiber <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">parent</span><span class=\"token operator\">:</span> fiber<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">dom</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 첫 번째 index 라면 자식, 아니라면 이전 형제자매로 fiber 추가</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> fiber<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> newFiber\n    <span class=\"token keyword\">else</span> prevSibling<span class=\"token punctuation\">.</span>sibling <span class=\"token operator\">=</span> newFiber\n\n    prevSibling <span class=\"token operator\">=</span> newFiber\n    index<span class=\"token operator\">++</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// TODO: return next unit of work</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>마지막은 탐색 작업이다. 자식, 형제자매, 부모의 형제자매 순서로 탐색을 진행한다. root fiber에 도달하여 더 이상 parent 가 존재하지 않는다면 종료한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...add dom node(생략)</span>\n  <span class=\"token comment\">// ...create new fibers(생략)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> fiber<span class=\"token punctuation\">.</span>child\n  <span class=\"token keyword\">let</span> nextFiber <span class=\"token operator\">=</span> fiber\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextFiber<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextFiber<span class=\"token punctuation\">.</span>sibling<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> nextFiber<span class=\"token punctuation\">.</span>sibling\n    nextFiber <span class=\"token operator\">=</span> nextFiber<span class=\"token punctuation\">.</span>parent\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"step-v-렌더와-커밋-단계-render-and-commit-phases\" style=\"position:relative;\"><a href=\"#step-v-%EB%A0%8C%EB%8D%94%EC%99%80-%EC%BB%A4%EB%B0%8B-%EB%8B%A8%EA%B3%84-render-and-commit-phases\" aria-label=\"step v 렌더와 커밋 단계 render and commit phases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step V: 렌더와 커밋 단계 (Render and Commit Phases)</h2>\n<p>하지만 문제가 있다. 엘리먼트에서 작업을 수행시마다 각각의 DOM에 새로운 노드를 추가해주고 있다. 브라우저가 렌더링이 진행되고 있는 중간에 난입할 수 있기 때문에 이 경우 유저는 미완성된 UI를 보게 된다. 이를 해결하기 위해 DOM을 변형시키는 부분을 제거한다.</p>\n<p><strong><code class=\"language-text\">performUnitOfWork()</code></strong>함수에서 parent fiber에 현재 fiber의 DOM 노드를 append 하는 로직을 제거하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// add dom node</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>fiber<span class=\"token punctuation\">.</span>dom<span class=\"token punctuation\">)</span> fiber<span class=\"token punctuation\">.</span>dom <span class=\"token operator\">=</span> <span class=\"token function\">createDom</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// if (fiber.parent) fiber.parent.dom.appendChild(fiber.dom)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>대신 현재 root fiber tree의 현황을 파악하는 <strong><code class=\"language-text\">wipRoot</code></strong>(Working In Progress Root)를 만들고 렌더링 작업이 완료되었을 때, 즉 <strong><code class=\"language-text\">nextUnitOfWork</code></strong>가 존재하지 않을 때 이를 commit하여 DOM tree를 만들도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">element<span class=\"token punctuation\">,</span> container</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// wipRoot는 현재 렌더링중인 fiber tree의 root를 참조한다</span>\n  wipRoot <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">dom</span><span class=\"token operator\">:</span> container<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">children</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>element<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n  nextUnitOfWork <span class=\"token operator\">=</span> wipRoot\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n<span class=\"token keyword\">let</span> wipRoot <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span></code></pre></div>\n<p>마지막으로 <strong><code class=\"language-text\">workLoop</code></strong> 에서 <strong><code class=\"language-text\">nextUnitofWork</code></strong>가 존재하지 않으면 <strong><code class=\"language-text\">commitRoot()</code></strong> 함수를 호출하여 재귀적으로 DOM tree를 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">commitRoot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">commitWork</span><span class=\"token punctuation\">(</span>wipRoot<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">)</span>\n  wipRoot <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">commitWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>fiber<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span>\n  <span class=\"token keyword\">const</span> domParent <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>dom\n  domParent<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>dom<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">commitWork</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">commitWork</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>sibling<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">deadline</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token comment\">// nextUnitOfWork가 존재하지 않으면 현재 wipRoot를 commit 한다</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>nextUnitOfWork <span class=\"token operator\">&amp;&amp;</span> wipRoot<span class=\"token punctuation\">)</span> <span class=\"token function\">commitRoot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span>workLoop<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"recap\" style=\"position:relative;\"><a href=\"#recap\" aria-label=\"recap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recap</h2>\n<p>리액트는 Fiber라는 자료구조를 활용해 렌더링 작업을 작게 나누고, 작업에 대한 우선순위를 부여해 더 중요한 UI업데이트가 먼저 발생할 수 있게 해준다. 이전에는 <strong><code class=\"language-text\">requestIdleCallback()</code>, <code class=\"language-text\">requestAnimationFrame()</code></strong> 을 사용했지만 현재는 <strong><code class=\"language-text\">scheduler</code></strong> 패키지를 사용한다.</p>\n<p>해당 포스팅의 마지막에는 렌더와 커밋 단계에 대해서 다루었다. 리액트의 렌더는 실제 렌더링이 아니다. 이는 새로운 Virtual DOM을 생성하는 과정이다. 그리고 커밋이 실제로 이전 Virtual DOM과의 비교를 통해 실제 DOM에 반영하는 과정이다. 이 과정을 통해 UI업데이트를 통합해 수행하고 사용자가 불완전한 UI를 보는 것을 예방할 수 있다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>reference</h2>\n<ul>\n<li><a href=\"https://velog.io/@cadenzah/react-concurrent-mode\">리액트 Concurrent Mode 번역글</a></li>\n<li><a href=\"https://github.com/pomber/didact/blob/master/didact.js\">Github: Build Your Own React</a></li>\n<li><a href=\"https://immigration9.github.io/react/2021/05/29/react-fiber-architecture.html\">React Fiber</a></li>\n<li><a href=\"https://bumkeyy.gitbook.io/bumkeyy-code/frontend/a-deep-dive-into-react-fiber-internals\">a deep dive into React Fiber internals</a></li>\n</ul>","frontmatter":{"title":"Build your own React: Concurrent Rendering과 Fiber","date":"April 01, 2022"}}},"pageContext":{"slug":"/React/Build Your Own React : ConcurrentMode와 Fiber/","previous":{"fields":{"slug":"/PS/PG Level2  양궁/"},"frontmatter":{"title":"[PG Level2] 카카오 양궁 (Node.js)"}},"next":{"fields":{"slug":"/Next.js/Next.js: SSR과 DataFetching/"},"frontmatter":{"title":"Next.js: SSR과 Next.js의 DataFetching"}}}},"staticQueryHashes":["2486386679","3128451518"]}