{"componentChunkName":"component---src-templates-blog-post-js","path":"/React/React.js 클래스컴포넌트의 생명주기/","result":{"data":{"site":{"siteMetadata":{"title":"Ingong's Log","author":"ingong","siteUrl":"https://ingong.github.io","comment":{"disqusShortName":"","utterances":"ingong/ingong.github.io"},"sponsor":{"buyMeACoffeeId":"ingong"}}},"markdownRemark":{"id":"3e0872ca-8109-57ca-8ecc-2d257fc8593f","excerpt":"최근에는 클래스 컴포넌트 대신 함수형 컴포넌트가 사용되고 있다. 그래서 해당 내용을 학습할 기회가 없었다. 하지만 리액트의 초기 설계단계에서 사용된만큼 리액트가 의도한 바를 이해하는데 도움이 될 것 같다는 생각이 들었다. 따라서 이번 글에서는 클래스 컴포넌트의 생명주기 메서드에 대해서 다뤄보려고 한다. 클래스형 컴포넌트의 생명 주기 메서드 모든 컴포넌트는…","html":"<p>최근에는 클래스 컴포넌트 대신 함수형 컴포넌트가 사용되고 있다. 그래서 해당 내용을 학습할 기회가 없었다. 하지만 리액트의 초기 설계단계에서 사용된만큼 리액트가 의도한 바를 이해하는데 도움이 될 것 같다는 생각이 들었다. 따라서 이번 글에서는 클래스 컴포넌트의 생명주기 메서드에 대해서 다뤄보려고 한다.</p>\n<h2 id=\"클래스형-컴포넌트의-생명-주기-메서드\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"클래스형 컴포넌트의 생명 주기 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스형 컴포넌트의 생명 주기 메서드</h2>\n<p>모든 컴포넌트는 3가지 단계를 가진다.</p>\n<ul>\n<li>초기화 단계</li>\n<li>업데이트 단계</li>\n<li>소멸 단계</li>\n</ul>\n<p>각 단계에서는 몇 개의 메서드들이 정해진 순서대로 호출된다. 각 단계 속에서 호출되는 메서드를 생명 주기 메서드라 한다.</p>\n<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 606px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 76.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACJklEQVQ4y31TaXPaQAzl//+dpmknhQBJvzQh6VASknDYBuPb+MYY4kHVk49JZ2g882ZXK+lZT6vtlO8l7fd7ynMgF8CuzvIWu13+wYa/+NfPOBwO1CmKgjaGSdOXV/p1N6LJ05QM02KYcq6t1nR3P6LRwyO9zea1r4K+MejpeUr3owdaqhptg7AidF2PLNuRZNtxyGEbCbBBikRNW7Vna31DNsc3xIjBGkZRRej7W2E3+TDg1WMbQYulIskA9jibLxRSmdw6QxiENaHr+RTHCUVxTHGScIVuLdkgg4NRdZKkLVDJOcKwIbQdV0hB5PEKG5JAiETYDsPzK59Tt+gsIW7GtGyWZdBqrUu/4JQEDlxxz1Ru+Jp9zSXBb39WIf4MqZAC6QK2Ua2/3TICStNM5MIXhOHnkuGEjEZOI3upqG3FzYreYoUqfWO2UwDgQkVymmWUZTupAAOMvet5pPBtPk9faPxnQr/HYxpPJjKvSIaaJE3bqrHHsHeOxyNFUSx/BFAhejlfLHk8NOmfzmNj1n1FDNqAl3TuE0L0UFFVAZoOQsh9fZvx65jJDCpMDB9WEENJ1Vf0POZ9Wj29siwl8arbo+HNT/rRvZbBNS2LLr5+o15/wOe31B/c0GB4S18uLvmpPYoqxHZ7fbruD+ny+5UUIYR42OhFKj1J+O87efC46QbJB8BfFAepEDnNBOCsczqdCGg+tKCVUa+RjFNcEfKKmP99fwGaTV6pDnoaFAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ReactClass\" title=\"ReactClass\" src=\"/static/5a351b1510fa02293de94e11e2c5a801/4d4a2/ReactClass.png\" srcset=\"/static/5a351b1510fa02293de94e11e2c5a801/5a46d/ReactClass.png 300w,\n/static/5a351b1510fa02293de94e11e2c5a801/0a47e/ReactClass.png 600w,\n/static/5a351b1510fa02293de94e11e2c5a801/4d4a2/ReactClass.png 606w\" sizes=\"(max-width: 606px) 100vw, 606px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n</div>\n<p>Render 단계를 브라우저의 렌더링과 혼동한 경우에 리액트의 메서드를 이해하는데 어려움이 있기 때문에 반드시 이 두 가지의 용어에 대한 정리가 필요하다. 이제는 초기화 단계, 업데이트 단계, 소멸 단계 각각을 알아보자.</p>\n<h2 id=\"초기화-단계\" style=\"position:relative;\"><a href=\"#%EC%B4%88%EA%B8%B0%ED%99%94-%EB%8B%A8%EA%B3%84\" aria-label=\"초기화 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>초기화 단계</h2>\n<p>초기화 단계에서는 최초 컴포넌트 인스턴스(클래스 컴포넌트이므로 인스턴스라고 한다)가 생성될 때 딱 한 번 수행한다. 초기화 단계에서 수행되는 메서드는 다음과 같다.</p>\n<ol>\n<li><code class=\"language-text\">constructor()</code></li>\n<li><code class=\"language-text\">static getDerivedStateFromProps()</code></li>\n<li><code class=\"language-text\">render()</code></li>\n<li><code class=\"language-text\">componentDidMount()</code></li>\n</ol>\n<h3 id=\"code-classlanguage-text1-constructorcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-text1-constructorcode\" aria-label=\"code classlanguage text1 constructorcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">1. constructor()</code></h3>\n<p>초기 상태값을 정의할 수 있다. 다른 생명 주기 메서드에서는 상태를 변경하기 위해서는 setState 를 호출해야한다. 메서드를 바인딩하거나, state 를 초기화하는 작업이 없다면 constructor 를 호출할 필요가 없다. 이 생성자는 해당 컴포넌트가 마운트 되기전에 호출된다. <code class=\"language-text\">React.Component</code> 를 상속한 컴포넌트의 생성자를 구현할 때는 다른 구문에 앞서 <code class=\"language-text\">super(props)</code> 를 호출야한다. 그렇지 않으면 <code class=\"language-text\">this.props</code> 가 생성자 내에서 정의되지 않아 버그로 이어질 수 있다.</p>\n<h3 id=\"code-classlanguage-text2-static-getderivedstatefrompropscode\" style=\"position:relative;\"><a href=\"#code-classlanguage-text2-static-getderivedstatefrompropscode\" aria-label=\"code classlanguage text2 static getderivedstatefrompropscode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">2. static getDerivedStateFromProps()</code></h3>\n<p>최초 마운트 시와 갱신 시 모두에서 render 메서드를 호출하기 전에 호출된다. 시간의 흐름에 따라 변하는 props 에 state 가 의존하는 경우에 사용한다. 주로 애니메이션과 관련한 속성값으로부터 상태값을 계산할 경우에 유용하게 사용된다.</p>\n<h3 id=\"code-classlanguage-text3-rendercode\" style=\"position:relative;\"><a href=\"#code-classlanguage-text3-rendercode\" aria-label=\"code classlanguage text3 rendercode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">3. render()</code></h3>\n<p><code class=\"language-text\">render</code> 메서드는 반드시 작성해야하는 메서드이며, <code class=\"language-text\">render</code> 메서드의 반환값은 화면에 보여질 내용을 결정한다. 그리고 이는 props 와 state 으로만 결정되어야한다.</p>\n<p><code class=\"language-text\">render</code> 메서드는 부수 효과를 발생시켜서는 안된다. 서버와 통신 또는 브라우저에 쿠키를 저장하는 등의 효과는 부수 효과이므로 <code class=\"language-text\">render</code> 메서드 외에 다른 메서드에서 처리해야한다.</p>\n<h3 id=\"code-classlanguage-text4-componentdidmountcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-text4-componentdidmountcode\" aria-label=\"code classlanguage text4 componentdidmountcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">4. componentDidMount()</code></h3>\n<p><code class=\"language-text\">render</code> 메서드의 반환값이 실제 돔에 반영된 이후에 호출된다. 이 메서드는 API 호출을 통해 데이터를 가져올 때 적합하며 그 이유는 <code class=\"language-text\">setState</code> 메서드가 마운트 이후에만 동작하기 때문이다.</p>\n<h2 id=\"업데이트-단계\" style=\"position:relative;\"><a href=\"#%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%8B%A8%EA%B3%84\" aria-label=\"업데이트 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>업데이트 단계</h2>\n<p>업데이트 단계는 초기화 단계와 소멸 단계 사이에서 반복해서 수행되며, 컴포넌트의 속성값 또는 상태값이 변경되면 업데이트가 수행된다. 업데이트 단계에서 실행되는 생명 주기 메서드는 다음과 같다.</p>\n<ol>\n<li><code class=\"language-text\">shouldComponentUpdate()</code></li>\n<li><code class=\"language-text\">render()</code></li>\n<li><code class=\"language-text\">getSnapshotBeforeUpdate()</code></li>\n<li><code class=\"language-text\">componentDidUpdate()</code></li>\n</ol>\n<h3 id=\"code-classlanguage-textshouldcomponentupdatecode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textshouldcomponentupdatecode\" aria-label=\"code classlanguage textshouldcomponentupdatecode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">shouldComponentUpdate()</code></h3>\n<p>이 메서드는 <strong>성능 최적화</strong>를 위해 존재한다. <code class=\"language-text\">shouldComponentUpdate(nextProps, nextState)</code> 의 메서드 구조는 다음과 같다. 이 메서드는 bool 값을 반환하며 참을 반환하면 <code class=\"language-text\">render</code> 메서드가 호출되고, 그렇지 않다면 <code class=\"language-text\">render</code> 메서드가 호출되지 않는다. 함수형 컴포넌트에서는 useMemo 를 통해 유사하게 동작하도록 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps<span class=\"token punctuation\">,</span> nextState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> price <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state\n    <span class=\"token keyword\">return</span> price <span class=\"token operator\">!==</span> nextState<span class=\"token punctuation\">.</span>price\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"code-classlanguage-textgetsnapshotbeforeupdatecode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textgetsnapshotbeforeupdatecode\" aria-label=\"code classlanguage textgetsnapshotbeforeupdatecode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">getSnapshotBeforeUpdate()</code></h3>\n<p>이 메서드는 렌더링 결과가 실제 돔에 반영되기 직전에 호출된다. 이전 돔 요소의 상태값을 가져오기 좋다.</p>\n<p><code class=\"language-text\">getSnapshotBeforeUpdate()</code> 와 <code class=\"language-text\">componentDidUpate()</code> 사이에 VirtualDOM 이 실제 DOM 에 반영되는 Commit 단계가 일어난다.</p>\n<p><code class=\"language-text\">getSnapshotBeforeUpdate()</code> 의 메서드 구조는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">getSnapshotBeforeUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevProps<span class=\"token punctuation\">,</span> prevState</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> snapshot</code></pre></div>\n<p>이 반환값은 <code class=\"language-text\">ComponentDidUpate</code> 메서드의 세 번째 인자로 들어간다. 따라서 이 메서드에서 이전 DOM 의 상태값을 반환하면, <code class=\"language-text\">componentDidUpdate</code> 메서드에서는 돔의 이전 상태값과 이후 상태값을 모두 알기 때문에 돔의 상태값의 변화를 알 수 있다.</p>\n<h3 id=\"code-classlanguage-textcomponentdidupatecode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textcomponentdidupatecode\" aria-label=\"code classlanguage textcomponentdidupatecode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">componentDidUpate()</code></h3>\n<p>이 메서드는 업데이트 단계에서 호출되는 마지막 생명주기 메서드이다. 구조는 다음과 같다.</p>\n<p><code class=\"language-text\">componentDidUpdate(prevProps, prevState, snapshot)</code></p>\n<p>해당 메서드는 가상 돔이 실제 돔에 반영된 후에 호출된다. 따라서 해당 메서드는 새로 반영된 돔의 상태값을 가장 빠르게 가져올 수 있는 생명주기 메서드이다.</p>\n<h2 id=\"소멸-단계\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EB%A9%B8-%EB%8B%A8%EA%B3%84\" aria-label=\"소멸 단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소멸 단계</h2>\n<h3 id=\"code-classlanguage-textcomponentwillunmountcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textcomponentwillunmountcode\" aria-label=\"code classlanguage textcomponentwillunmountcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">componentWillUnmount()</code></h3>\n<p>이 메서드는 소멸 단계에서 호출되는 유일한 생명 주기 메서드이다. 끝나지 않은 네트워크 요청 취소, 타이머 해제, 구독 해제 등의 작업을 처리하기 좋다. <code class=\"language-text\">componentDidMount</code> 메서드가 호출되었다면 <code class=\"language-text\">componentWillUnMount</code> 도 호출이 보장된다.</p>\n<h2 id=\"에러-처리\" style=\"position:relative;\"><a href=\"#%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC\" aria-label=\"에러 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>에러 처리</h2>\n<h3 id=\"code-classlanguage-textstatic-getderivedstatefromerrorerror-amp-componentdidcatcherror-infocode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textstatic-getderivedstatefromerrorerror-amp-componentdidcatcherror-infocode\" aria-label=\"code classlanguage textstatic getderivedstatefromerrorerror amp componentdidcatcherror infocode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">static getDerivedStateFromError(error) &amp; componentDidCatch(error, info)</code></h3>\n<p>생명주기 메서드에서 에러가 발생한 경우 두 가지 메서드를 구현한 가장 가까운 부모 컴포넌트를 찾는다. error 는 전달된 에러 객체이며, info 는 어떤 컴포넌트에서 예외가 발생했는지 알려준다. getDerivedStateFromError 정적 메서드는 에러 정보를 상태값에 저장해서 화면에 나타내는 용도로 사용한다. componentDidCatch 는 에러 정보를 상태값에 저장해서 화면에 나타낼 수 있다. <code class=\"language-text\">componentDidCatch</code> 는 커밋 단계에 호출되기 때문에 부수 효과를 발생시켜도 된다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>리액트에서 데이터 변경에 의한 화면 업데이트는 렌더 단계와 커밋 단계를 거친다. 렌더 단계에서는 실제 돔에 반영할 변경 사항을 파악하고, 커밋 단계에서는 파악된 변경 사항을 실제 돔에 반영한다. <code class=\"language-text\">concurrent</code> 모드에서는 렌더 단계에서 실행을 멈췄다가 나중에 다시 실행하는 과정에서 렌더단계에서의 같은 생명 주기 메서드를 여러 번 호출할 수 있다. 이러한 이유로 렌더단계에서는 부수효과를 발생시켜서는 안된다는 걸로도 추측할 수 있다.</p>\n<p>우리가 함수형 컴포넌트에서 자주 사용하는 useEffect 훅도 ComponentDidMount 와 ComponentDidUpate 그리고 ComponentWillUnMount 의 생명주기 메서드와 유사하게 사용되기 때문에 우리는 커밋 단계에서 부수효과를 발생시키고 있었다는 것을 알 수 있다.</p>\n<p>커밋단계에서 호출하는 메서드는 다음 4가지이다.<code class=\"language-text\">getSnapshotBeforeUpdate, componentDidMount, componentDidUpdate, componentDidCatch</code> 이다. 이 메서드를 제외하고는 렌더단계에서 호출된다. <code class=\"language-text\">concurrent</code> 모드에서도 커밋 단계에서의 메서드는 1회만 호출되기 때문에 에러 정보는 <code class=\"language-text\">componentDidCatch</code> 와 같은 에러 정보를 서버로 전송하는 메서드를 활용해 실행하는 것이 좋다. 만약 UI 에 반영하는 경우에는 <code class=\"language-text\">getDerivedStateFromError</code> 를 사용하면 된다고 한다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REFERENCE</h2>\n<ul>\n<li><a href=\"https://velog.io/@dev-mish-mash/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%A1%B0%ED%99%94Reconciliation-%EA%B3%BC%EC%A0%95-%EC%A0%95%EB%A6%AC\">리액트 조화 과정</a></li>\n<li><a href=\"https://blog.eunsukim.me/blog/2021-08-24---Build-your-own-React-Concurrency\">Build Your Own React 관련 정리 글</a></li>\n</ul>","frontmatter":{"title":"React 클래스 컴포넌트의 생명주기","date":"March 17, 2022"}}},"pageContext":{"slug":"/React/React.js 클래스컴포넌트의 생명주기/","previous":{"fields":{"slug":"/PS/BOJ 1911 흙길보수하기/"},"frontmatter":{"title":"[백준 1911] 흙길 보수하기 (Node.js)"}},"next":{"fields":{"slug":"/React/React.js란/"},"frontmatter":{"title":"React.js란?"}}}},"staticQueryHashes":["2486386679","3128451518"]}